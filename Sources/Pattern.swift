
import java_swift
import java_lang

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// JAVA_HOME: /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home ///
/// Tue Dec 20 11:30:04 GMT 2016 ///

/// class java.util.regex.Pattern ///

open class Pattern: java_lang.JavaObject, /* java.io.Serializable */ UnclassedProtocol {

    public convenience init?( casting object: java_lang.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        if !object.validDownCast( toJavaClass: "java.util.regex.Pattern", file, line ) {
            return nil
        }
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var PatternJNIClass: jclass?

    /// public static final int java.util.regex.Pattern.UNIX_LINES

    private static var UNIX_LINES_FieldID: jfieldID?

    open static var UNIX_LINES: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "UNIX_LINES", fieldType: "I", fieldCache: &UNIX_LINES_FieldID, className: "java/util/regex/Pattern", classCache: &PatternJNIClass )
            return JNIType.decode( type: Int(), from: __value )
        }
    }

    /// public static final int java.util.regex.Pattern.CASE_INSENSITIVE

    private static var CASE_INSENSITIVE_FieldID: jfieldID?

    open static var CASE_INSENSITIVE: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "CASE_INSENSITIVE", fieldType: "I", fieldCache: &CASE_INSENSITIVE_FieldID, className: "java/util/regex/Pattern", classCache: &PatternJNIClass )
            return JNIType.decode( type: Int(), from: __value )
        }
    }

    /// public static final int java.util.regex.Pattern.COMMENTS

    private static var COMMENTS_FieldID: jfieldID?

    open static var COMMENTS: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "COMMENTS", fieldType: "I", fieldCache: &COMMENTS_FieldID, className: "java/util/regex/Pattern", classCache: &PatternJNIClass )
            return JNIType.decode( type: Int(), from: __value )
        }
    }

    /// public static final int java.util.regex.Pattern.MULTILINE

    private static var MULTILINE_FieldID: jfieldID?

    open static var MULTILINE: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "MULTILINE", fieldType: "I", fieldCache: &MULTILINE_FieldID, className: "java/util/regex/Pattern", classCache: &PatternJNIClass )
            return JNIType.decode( type: Int(), from: __value )
        }
    }

    /// public static final int java.util.regex.Pattern.LITERAL

    private static var LITERAL_FieldID: jfieldID?

    open static var LITERAL: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "LITERAL", fieldType: "I", fieldCache: &LITERAL_FieldID, className: "java/util/regex/Pattern", classCache: &PatternJNIClass )
            return JNIType.decode( type: Int(), from: __value )
        }
    }

    /// public static final int java.util.regex.Pattern.DOTALL

    private static var DOTALL_FieldID: jfieldID?

    open static var DOTALL: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "DOTALL", fieldType: "I", fieldCache: &DOTALL_FieldID, className: "java/util/regex/Pattern", classCache: &PatternJNIClass )
            return JNIType.decode( type: Int(), from: __value )
        }
    }

    /// public static final int java.util.regex.Pattern.UNICODE_CASE

    private static var UNICODE_CASE_FieldID: jfieldID?

    open static var UNICODE_CASE: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "UNICODE_CASE", fieldType: "I", fieldCache: &UNICODE_CASE_FieldID, className: "java/util/regex/Pattern", classCache: &PatternJNIClass )
            return JNIType.decode( type: Int(), from: __value )
        }
    }

    /// public static final int java.util.regex.Pattern.CANON_EQ

    private static var CANON_EQ_FieldID: jfieldID?

    open static var CANON_EQ: Int {
        get {
            let __value = JNIField.GetStaticIntField( fieldName: "CANON_EQ", fieldType: "I", fieldCache: &CANON_EQ_FieldID, className: "java/util/regex/Pattern", classCache: &PatternJNIClass )
            return JNIType.decode( type: Int(), from: __value )
        }
    }

    /// private static final long java.util.regex.Pattern.serialVersionUID

    /// private java.lang.String java.util.regex.Pattern.pattern

    /// private int java.util.regex.Pattern.flags

    /// private transient volatile boolean java.util.regex.Pattern.compiled

    /// private transient java.lang.String java.util.regex.Pattern.normalizedPattern

    /// transient java.util.regex.Pattern$Node java.util.regex.Pattern.root

    /// transient java.util.regex.Pattern$Node java.util.regex.Pattern.matchRoot

    /// transient int[] java.util.regex.Pattern.buffer

    /// transient java.util.regex.Pattern$GroupHead[] java.util.regex.Pattern.groupNodes

    /// private transient int[] java.util.regex.Pattern.temp

    /// transient int java.util.regex.Pattern.capturingGroupCount

    /// transient int java.util.regex.Pattern.localCount

    /// private transient int java.util.regex.Pattern.cursor

    /// private transient int java.util.regex.Pattern.patternLength

    /// static final int java.util.regex.Pattern.MAX_REPS

    /// static final int java.util.regex.Pattern.GREEDY

    /// static final int java.util.regex.Pattern.LAZY

    /// static final int java.util.regex.Pattern.POSSESSIVE

    /// static final int java.util.regex.Pattern.INDEPENDENT

    /// static java.util.regex.Pattern$Node java.util.regex.Pattern.lookbehindEnd

    /// static java.util.regex.Pattern$Node java.util.regex.Pattern.accept

    /// static java.util.regex.Pattern$Node java.util.regex.Pattern.lastAccept

    /// static final boolean java.util.regex.Pattern.$assertionsDisabled

    /// private java.util.regex.Pattern(java.lang.String,int)

    /// private java.util.regex.Pattern$CharProperty java.util.regex.Pattern.clazz(boolean)

    /// public java.lang.String java.util.regex.Pattern.toString()

    /// public int java.util.regex.Pattern.flags()

    private static var flags_MethodID_1: jmethodID?

    open func flags() -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "flags", methodSig: "()I", methodCache: &Pattern.flags_MethodID_1, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }


    /// private void java.util.regex.Pattern.append(int,int)

    /// private int java.util.regex.Pattern.getClass(int)

    /// public static boolean java.util.regex.Pattern.matches(java.lang.String,java.lang.CharSequence)

    private static var matches_MethodID_2: jmethodID?

    open class func matches( arg0: String?, arg1: java_lang.CharSequence? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = jvalue( l: arg1?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/regex/Pattern", classCache: &PatternJNIClass, methodName: "matches", methodSig: "(Ljava/lang/String;Ljava/lang/CharSequence;)Z", methodCache: &matches_MethodID_2, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open class func matches( _ _arg0: String?, _ _arg1: java_lang.CharSequence? ) -> Bool {
        return matches( arg0: _arg0, arg1: _arg1 )
    }

    /// public java.lang.String[] java.util.regex.Pattern.split(java.lang.CharSequence)

    private static var split_MethodID_3: jmethodID?

    open func split( arg0: java_lang.CharSequence? ) -> [String]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "split", methodSig: "(Ljava/lang/CharSequence;)[Ljava/lang/String;", methodCache: &Pattern.split_MethodID_3, args: &__args, locals: &__locals )
        return JNIType.decode( type: [String](), from: __return )
    }

    open func split( _ _arg0: java_lang.CharSequence? ) -> [String]! {
        return split( arg0: _arg0 )
    }

    /// public java.lang.String[] java.util.regex.Pattern.split(java.lang.CharSequence,int)

    private static var split_MethodID_4: jmethodID?

    open func split( arg0: java_lang.CharSequence?, arg1: Int ) -> [String]! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "split", methodSig: "(Ljava/lang/CharSequence;I)[Ljava/lang/String;", methodCache: &Pattern.split_MethodID_4, args: &__args, locals: &__locals )
        return JNIType.decode( type: [String](), from: __return )
    }

    open func split( _ _arg0: java_lang.CharSequence?, _ _arg1: Int ) -> [String]! {
        return split( arg0: _arg0, arg1: _arg1 )
    }

    /// private void java.util.regex.Pattern.compile()

    /// public static java.util.regex.Pattern java.util.regex.Pattern.compile(java.lang.String)

    private static var compile_MethodID_5: jmethodID?

    open class func compile( arg0: String? ) -> Pattern! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/regex/Pattern", classCache: &PatternJNIClass, methodName: "compile", methodSig: "(Ljava/lang/String;)Ljava/util/regex/Pattern;", methodCache: &compile_MethodID_5, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Pattern( javaObject: __return ) : nil
    }

    open class func compile( _ _arg0: String? ) -> Pattern! {
        return compile( arg0: _arg0 )
    }

    /// public static java.util.regex.Pattern java.util.regex.Pattern.compile(java.lang.String,int)

    private static var compile_MethodID_6: jmethodID?

    open class func compile( arg0: String?, arg1: Int ) -> Pattern! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/regex/Pattern", classCache: &PatternJNIClass, methodName: "compile", methodSig: "(Ljava/lang/String;I)Ljava/util/regex/Pattern;", methodCache: &compile_MethodID_6, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Pattern( javaObject: __return ) : nil
    }

    open class func compile( _ _arg0: String?, _ _arg1: Int ) -> Pattern! {
        return compile( arg0: _arg0, arg1: _arg1 )
    }

    /// public java.util.regex.Matcher java.util.regex.Pattern.matcher(java.lang.CharSequence)

    private static var matcher_MethodID_7: jmethodID?

    open func matcher( arg0: java_lang.CharSequence? ) -> Matcher! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "matcher", methodSig: "(Ljava/lang/CharSequence;)Ljava/util/regex/Matcher;", methodCache: &Pattern.matcher_MethodID_7, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Matcher( javaObject: __return ) : nil
    }

    open func matcher( _ _arg0: java_lang.CharSequence? ) -> Matcher! {
        return matcher( arg0: _arg0 )
    }

    /// private int java.util.regex.Pattern.next()

    /// static boolean java.util.regex.Pattern.access$200(int,int,int)

    /// static int java.util.regex.Pattern.access$300(java.lang.CharSequence,int,int)

    /// static boolean java.util.regex.Pattern.access$400(java.util.regex.Matcher,int,java.lang.CharSequence)

    /// private void java.util.regex.Pattern.readObject(java.io.ObjectInputStream) throws java.io.IOException,java.lang.ClassNotFoundException

    /// private void java.util.regex.Pattern.mark(int)

    /// static java.util.regex.Pattern$CharProperty java.util.regex.Pattern.access$600(int,int)

    /// private int java.util.regex.Pattern.peek()

    /// private void java.util.regex.Pattern.normalize()

    /// private void java.util.regex.Pattern.accept(int,java.lang.String)

    /// private int java.util.regex.Pattern.read()

    /// private int java.util.regex.Pattern.c()

    /// private java.util.regex.PatternSyntaxException java.util.regex.Pattern.error(java.lang.String)

    /// private java.util.regex.Pattern$Node java.util.regex.Pattern.ref(int)

    /// private java.util.regex.Pattern$Node java.util.regex.Pattern.sequence(java.util.regex.Pattern$Node)

    /// private int java.util.regex.Pattern.skip()

    /// private int java.util.regex.Pattern.escape(boolean,boolean)

    /// public static java.lang.String java.util.regex.Pattern.quote(java.lang.String)

    private static var quote_MethodID_8: jmethodID?

    open class func quote( arg0: String? ) -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/regex/Pattern", classCache: &PatternJNIClass, methodName: "quote", methodSig: "(Ljava/lang/String;)Ljava/lang/String;", methodCache: &quote_MethodID_8, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }

    open class func quote( _ _arg0: String? ) -> String! {
        return quote( arg0: _arg0 )
    }

    /// private static final boolean java.util.regex.Pattern.isSurrogate(int)

    /// public java.lang.String java.util.regex.Pattern.pattern()

    private static var pattern_MethodID_9: jmethodID?

    open func pattern() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "pattern", methodSig: "()Ljava/lang/String;", methodCache: &Pattern.pattern_MethodID_9, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }


    /// private int java.util.regex.Pattern.normalizeCharClass(java.lang.StringBuilder,int)

    /// private java.lang.String java.util.regex.Pattern.produceEquivalentAlternation(java.lang.String)

    /// private java.lang.String[] java.util.regex.Pattern.producePermutations(java.lang.String)

    /// private java.lang.String java.util.regex.Pattern.composeOneStep(java.lang.String)

    /// private void java.util.regex.Pattern.RemoveQEQuoting()

    /// private static void java.util.regex.Pattern.printObjectTree(java.util.regex.Pattern$Node)

    /// private boolean java.util.regex.Pattern.has(int)

    /// private int java.util.regex.Pattern.readEscaped()

    /// private int java.util.regex.Pattern.nextEscaped()

    /// private int java.util.regex.Pattern.peekPastWhitespace(int)

    /// private int java.util.regex.Pattern.parsePastWhitespace(int)

    /// private int java.util.regex.Pattern.parsePastLine()

    /// private int java.util.regex.Pattern.peekPastLine()

    /// private boolean java.util.regex.Pattern.isLineSeparator(int)

    /// private void java.util.regex.Pattern.unread()

    /// private boolean java.util.regex.Pattern.findSupplementary(int,int)

    /// private static final boolean java.util.regex.Pattern.isSupplementary(int)

    /// private java.util.regex.Pattern$Node java.util.regex.Pattern.expr(java.util.regex.Pattern$Node)

    /// private java.util.regex.Pattern$Node java.util.regex.Pattern.atom()

    /// private java.util.regex.Pattern$CharProperty java.util.regex.Pattern.bitsOrSingle(java.util.regex.Pattern$BitClass,int)

    /// private java.util.regex.Pattern$CharProperty java.util.regex.Pattern.range(java.util.regex.Pattern$BitClass)

    /// private int java.util.regex.Pattern.single()

    /// private java.util.regex.Pattern$CharProperty java.util.regex.Pattern.family(boolean)

    /// private java.util.regex.Pattern$CharProperty java.util.regex.Pattern.unicodeBlockPropertyFor(java.lang.String)

    /// private java.util.regex.Pattern$CharProperty java.util.regex.Pattern.charPropertyNodeFor(java.lang.String)

    /// private java.util.regex.Pattern$Node java.util.regex.Pattern.group0()

    /// private java.util.regex.Pattern$Node java.util.regex.Pattern.createGroup(boolean)

    /// private void java.util.regex.Pattern.addFlag()

    /// private void java.util.regex.Pattern.subFlag()

    /// private java.util.regex.Pattern$Node java.util.regex.Pattern.closure(java.util.regex.Pattern$Node)

    /// private int java.util.regex.Pattern.o()

    /// private int java.util.regex.Pattern.x()

    /// private int java.util.regex.Pattern.u()

    /// private static final int java.util.regex.Pattern.countChars(java.lang.CharSequence,int,int)

    /// private static final int java.util.regex.Pattern.countCodePoints(java.lang.CharSequence)

    /// private java.util.regex.Pattern$CharProperty java.util.regex.Pattern.newSingle(int)

    /// private java.util.regex.Pattern$Node java.util.regex.Pattern.newSlice(int[],int,boolean)

    /// private static boolean java.util.regex.Pattern.inRange(int,int,int)

    /// private static java.util.regex.Pattern$CharProperty java.util.regex.Pattern.rangeFor(int,int)

    /// private java.util.regex.Pattern$CharProperty java.util.regex.Pattern.caseInsensitiveRangeFor(int,int)

    /// private static java.util.regex.Pattern$CharProperty java.util.regex.Pattern.union(java.util.regex.Pattern$CharProperty,java.util.regex.Pattern$CharProperty)

    /// private static java.util.regex.Pattern$CharProperty java.util.regex.Pattern.intersection(java.util.regex.Pattern$CharProperty,java.util.regex.Pattern$CharProperty)

    /// private static java.util.regex.Pattern$CharProperty java.util.regex.Pattern.setDifference(java.util.regex.Pattern$CharProperty,java.util.regex.Pattern$CharProperty)

    /// private static boolean java.util.regex.Pattern.hasBaseCharacter(java.util.regex.Matcher,int,java.lang.CharSequence)

}
