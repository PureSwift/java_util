
import java_swift

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class java.util.concurrent.ThreadLocalRandom ///

open class ThreadLocalRandom: Random {

    public convenience init?( casting object: java_swift.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var ThreadLocalRandomJNIClass: jclass?

    /// private static final java.util.concurrent.atomic.AtomicInteger java.util.concurrent.ThreadLocalRandom.probeGenerator

    /// private static final java.util.concurrent.atomic.AtomicLong java.util.concurrent.ThreadLocalRandom.seeder

    /// private static final long java.util.concurrent.ThreadLocalRandom.GAMMA

    /// private static final int java.util.concurrent.ThreadLocalRandom.PROBE_INCREMENT

    /// private static final long java.util.concurrent.ThreadLocalRandom.SEEDER_INCREMENT

    /// private static final double java.util.concurrent.ThreadLocalRandom.DOUBLE_UNIT

    /// private static final float java.util.concurrent.ThreadLocalRandom.FLOAT_UNIT

    /// private static final java.lang.ThreadLocal java.util.concurrent.ThreadLocalRandom.nextLocalGaussian

    /// boolean java.util.concurrent.ThreadLocalRandom.initialized

    /// static final java.util.concurrent.ThreadLocalRandom java.util.concurrent.ThreadLocalRandom.instance

    /// static final java.lang.String java.util.concurrent.ThreadLocalRandom.BadBound

    /// static final java.lang.String java.util.concurrent.ThreadLocalRandom.BadRange

    /// static final java.lang.String java.util.concurrent.ThreadLocalRandom.BadSize

    /// private static final long java.util.concurrent.ThreadLocalRandom.serialVersionUID

    /// private static final java.io.ObjectStreamField[] java.util.concurrent.ThreadLocalRandom.serialPersistentFields

    /// private static final sun.misc.Unsafe java.util.concurrent.ThreadLocalRandom.UNSAFE

    /// private static final long java.util.concurrent.ThreadLocalRandom.SEED

    /// private static final long java.util.concurrent.ThreadLocalRandom.PROBE

    /// private static final long java.util.concurrent.ThreadLocalRandom.SECONDARY

    /// static final long java.util.Random.serialVersionUID

    /// private final java.util.concurrent.atomic.AtomicLong java.util.Random.seed

    /// private static final long java.util.Random.multiplier

    /// private static final long java.util.Random.addend

    /// private static final long java.util.Random.mask

    /// private static final double java.util.Random.DOUBLE_UNIT

    /// static final java.lang.String java.util.Random.BadBound

    /// static final java.lang.String java.util.Random.BadRange

    /// static final java.lang.String java.util.Random.BadSize

    /// private static final java.util.concurrent.atomic.AtomicLong java.util.Random.seedUniquifier

    /// private double java.util.Random.nextNextGaussian

    /// private boolean java.util.Random.haveNextNextGaussian

    /// private static final java.io.ObjectStreamField[] java.util.Random.serialPersistentFields

    /// private static final sun.misc.Unsafe java.util.Random.unsafe

    /// private static final long java.util.Random.seedOffset

    /// private java.util.concurrent.ThreadLocalRandom()

    /// protected int java.util.concurrent.ThreadLocalRandom.next(int)

    private static var next_MethodID_1: jmethodID?

    override open func next( bits: Int ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: bits, locals: &__locals )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "next", methodSig: "(I)I", methodCache: &ThreadLocalRandom.next_MethodID_1, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int(), from: __return )
    }

    override open func next( _ _bits: Int ) -> Int {
        return next( bits: _bits )
    }

    /// public static java.util.concurrent.ThreadLocalRandom java.util.concurrent.ThreadLocalRandom.current()

    private static var current_MethodID_2: jmethodID?

    open class func current() -> ThreadLocalRandom! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/concurrent/ThreadLocalRandom", classCache: &ThreadLocalRandomJNIClass, methodName: "current", methodSig: "()Ljava/util/concurrent/ThreadLocalRandom;", methodCache: &current_MethodID_2, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ThreadLocalRandom( javaObject: __return ) : nil
    }


    /// private void java.util.concurrent.ThreadLocalRandom.writeObject(java.io.ObjectOutputStream) throws java.io.IOException

    /// private java.lang.Object java.util.concurrent.ThreadLocalRandom.readResolve()

    /// public int java.util.concurrent.ThreadLocalRandom.nextInt()

    /// public int java.util.concurrent.ThreadLocalRandom.nextInt(int)

    /// public int java.util.concurrent.ThreadLocalRandom.nextInt(int,int)

    private static var nextInt_MethodID_3: jmethodID?

    open func nextInt( origin: Int, bound: Int ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: origin, locals: &__locals )
        __args[1] = JNIType.toJava( value: bound, locals: &__locals )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "nextInt", methodSig: "(II)I", methodCache: &ThreadLocalRandom.nextInt_MethodID_3, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int(), from: __return )
    }

    open func nextInt( _ _origin: Int, _ _bound: Int ) -> Int {
        return nextInt( origin: _origin, bound: _bound )
    }

    /// public double java.util.concurrent.ThreadLocalRandom.nextDouble()

    /// public double java.util.concurrent.ThreadLocalRandom.nextDouble(double,double)

    private static var nextDouble_MethodID_4: jmethodID?

    open func nextDouble( origin: Double, bound: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: origin, locals: &__locals )
        __args[1] = JNIType.toJava( value: bound, locals: &__locals )
        let __return = JNIMethod.CallDoubleMethod( object: javaObject, methodName: "nextDouble", methodSig: "(DD)D", methodCache: &ThreadLocalRandom.nextDouble_MethodID_4, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Double(), from: __return )
    }

    open func nextDouble( _ _origin: Double, _ _bound: Double ) -> Double {
        return nextDouble( origin: _origin, bound: _bound )
    }

    /// public double java.util.concurrent.ThreadLocalRandom.nextDouble(double)

    private static var nextDouble_MethodID_5: jmethodID?

    open func nextDouble( bound: Double ) -> Double {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: bound, locals: &__locals )
        let __return = JNIMethod.CallDoubleMethod( object: javaObject, methodName: "nextDouble", methodSig: "(D)D", methodCache: &ThreadLocalRandom.nextDouble_MethodID_5, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Double(), from: __return )
    }

    open func nextDouble( _ _bound: Double ) -> Double {
        return nextDouble( bound: _bound )
    }

    /// public java.util.stream.LongStream java.util.concurrent.ThreadLocalRandom.longs()

    /// public java.util.stream.LongStream java.util.concurrent.ThreadLocalRandom.longs(long,long,long)

    /// public java.util.stream.LongStream java.util.concurrent.ThreadLocalRandom.longs(long)

    /// public java.util.stream.LongStream java.util.concurrent.ThreadLocalRandom.longs(long,long)

    /// public long java.util.concurrent.ThreadLocalRandom.nextLong()

    /// public long java.util.concurrent.ThreadLocalRandom.nextLong(long,long)

    private static var nextLong_MethodID_6: jmethodID?

    open func nextLong( origin: Int64, bound: Int64 ) -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: origin, locals: &__locals )
        __args[1] = JNIType.toJava( value: bound, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "nextLong", methodSig: "(JJ)J", methodCache: &ThreadLocalRandom.nextLong_MethodID_6, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int64(), from: __return )
    }

    open func nextLong( _ _origin: Int64, _ _bound: Int64 ) -> Int64 {
        return nextLong( origin: _origin, bound: _bound )
    }

    /// public long java.util.concurrent.ThreadLocalRandom.nextLong(long)

    private static var nextLong_MethodID_7: jmethodID?

    open func nextLong( bound: Int64 ) -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: bound, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "nextLong", methodSig: "(J)J", methodCache: &ThreadLocalRandom.nextLong_MethodID_7, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int64(), from: __return )
    }

    open func nextLong( _ _bound: Int64 ) -> Int64 {
        return nextLong( bound: _bound )
    }

    /// final double java.util.concurrent.ThreadLocalRandom.internalNextDouble(double,double)

    /// final int java.util.concurrent.ThreadLocalRandom.internalNextInt(int,int)

    /// final long java.util.concurrent.ThreadLocalRandom.internalNextLong(long,long)

    /// static final int java.util.concurrent.ThreadLocalRandom.getProbe()

    /// static final void java.util.concurrent.ThreadLocalRandom.localInit()

    /// static final int java.util.concurrent.ThreadLocalRandom.advanceProbe(int)

    /// public void java.util.concurrent.ThreadLocalRandom.setSeed(long)

    /// public double java.util.concurrent.ThreadLocalRandom.nextGaussian()

    /// private static long java.util.concurrent.ThreadLocalRandom.mix64(long)

    /// private static int java.util.concurrent.ThreadLocalRandom.mix32(long)

    /// final long java.util.concurrent.ThreadLocalRandom.nextSeed()

    /// private static long java.util.concurrent.ThreadLocalRandom.initialSeed()

    /// public java.util.stream.IntStream java.util.concurrent.ThreadLocalRandom.ints(long)

    /// public java.util.stream.IntStream java.util.concurrent.ThreadLocalRandom.ints()

    /// public java.util.stream.IntStream java.util.concurrent.ThreadLocalRandom.ints(long,int,int)

    /// public java.util.stream.IntStream java.util.concurrent.ThreadLocalRandom.ints(int,int)

    /// public java.util.stream.DoubleStream java.util.concurrent.ThreadLocalRandom.doubles(long)

    /// public java.util.stream.DoubleStream java.util.concurrent.ThreadLocalRandom.doubles()

    /// public java.util.stream.DoubleStream java.util.concurrent.ThreadLocalRandom.doubles(double,double)

    /// public java.util.stream.DoubleStream java.util.concurrent.ThreadLocalRandom.doubles(long,double,double)

    /// static final int java.util.concurrent.ThreadLocalRandom.nextSecondarySeed()

    /// public boolean java.util.concurrent.ThreadLocalRandom.nextBoolean()

    /// public float java.util.concurrent.ThreadLocalRandom.nextFloat()

}

