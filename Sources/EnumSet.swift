
import java_swift
import java_lang

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class java.util.EnumSet ///

open class EnumSet: AbstractSet, java_lang.Cloneable {////}, /* java.io.Serializable */ UnclassedProtocol {

    public convenience init?( casting object: java_swift.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        if !object.validDownCast( toJavaClass: "java.util.EnumSet", file, line ) {
            return nil
        }
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var EnumSetJNIClass: jclass?

    /// final java.lang.Class java.util.EnumSet.elementType

    /// final java.lang.Enum[] java.util.EnumSet.universe

    /// private static java.lang.Enum[] java.util.EnumSet.ZERO_LENGTH_ENUM_ARRAY

    /// private static final int java.util.AbstractCollection.MAX_ARRAY_SIZE

    /// java.util.EnumSet(java.lang.Class,java.lang.Enum[])

    /// public java.lang.Object java.util.EnumSet.clone() throws java.lang.CloneNotSupportedException

    private static var clone_MethodID_1: jmethodID?

    override open func clone() throws /* java.lang.CloneNotSupportedException */ -> java_swift.JavaObject! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "clone", methodSig: "()Ljava/lang/Object;", methodCache: &EnumSet.clone_MethodID_1, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.CloneNotSupportedException( javaObject: throwable )
        }
        return __return != nil ? java_swift.JavaObject( javaObject: __return ) : nil
    }


    /// public java.util.EnumSet java.util.EnumSet.clone()

//    private static var clone_MethodID_2: jmethodID?
//
//    override open func clone() -> EnumSet! {
//        var __args = [jvalue]( repeating: jvalue(), count: 1 )
//        var __locals = [jobject]()
//        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "clone", methodSig: "()Ljava/util/EnumSet;", methodCache: &EnumSet.clone_MethodID_2, args: &__args, locals: &__locals )
//        defer { JNI.DeleteLocalRef( __return ) }
//        return __return != nil ? EnumSet( javaObject: __return ) : nil
//    }


    /// public static java.util.EnumSet java.util.EnumSet.copyOf(java.util.EnumSet)

    private static var copyOf_MethodID_3: jmethodID?

    open class func copyOf( s: EnumSet? ) -> EnumSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: s, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/EnumSet", classCache: &EnumSetJNIClass, methodName: "copyOf", methodSig: "(Ljava/util/EnumSet;)Ljava/util/EnumSet;", methodCache: &copyOf_MethodID_3, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? EnumSet( javaObject: __return ) : nil
    }

    open class func copyOf( _ _s: EnumSet? ) -> EnumSet! {
        return copyOf( s: _s )
    }

    /// public static java.util.EnumSet java.util.EnumSet.copyOf(java.util.Collection)

    private static var copyOf_MethodID_4: jmethodID?

    open class func copyOf( c: Collection? ) -> EnumSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: c, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/EnumSet", classCache: &EnumSetJNIClass, methodName: "copyOf", methodSig: "(Ljava/util/Collection;)Ljava/util/EnumSet;", methodCache: &copyOf_MethodID_4, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? EnumSet( javaObject: __return ) : nil
    }

    open class func copyOf( _ _c: Collection? ) -> EnumSet! {
        return copyOf( c: _c )
    }

    /// abstract void java.util.EnumSet.addAll()

    /// static java.lang.Enum[] java.util.EnumSet.access$000()

    /// private void java.util.EnumSet.readObject(java.io.ObjectInputStream) throws java.io.InvalidObjectException

    /// public static java.util.EnumSet java.util.EnumSet.of(java.lang.Enum,java.lang.Enum,java.lang.Enum,java.lang.Enum)

    private static var of_MethodID_5: jmethodID?

    open class func of( e1: java_lang.Enum?, e2: java_lang.Enum?, e3: java_lang.Enum?, e4: java_lang.Enum? ) -> EnumSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: e1, locals: &__locals )
        __args[1] = JNIType.toJava( value: e2, locals: &__locals )
        __args[2] = JNIType.toJava( value: e3, locals: &__locals )
        __args[3] = JNIType.toJava( value: e4, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/EnumSet", classCache: &EnumSetJNIClass, methodName: "of", methodSig: "(Ljava/lang/Enum;Ljava/lang/Enum;Ljava/lang/Enum;Ljava/lang/Enum;)Ljava/util/EnumSet;", methodCache: &of_MethodID_5, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? EnumSet( javaObject: __return ) : nil
    }

    open class func of( _ _e1: java_lang.Enum?, _ _e2: java_lang.Enum?, _ _e3: java_lang.Enum?, _ _e4: java_lang.Enum? ) -> EnumSet! {
        return of( e1: _e1, e2: _e2, e3: _e3, e4: _e4 )
    }

    /// public static java.util.EnumSet java.util.EnumSet.of(java.lang.Enum,java.lang.Enum,java.lang.Enum,java.lang.Enum,java.lang.Enum)

    private static var of_MethodID_6: jmethodID?

    open class func of( e1: java_lang.Enum?, e2: java_lang.Enum?, e3: java_lang.Enum?, e4: java_lang.Enum?, e5: java_lang.Enum? ) -> EnumSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 5 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: e1, locals: &__locals )
        __args[1] = JNIType.toJava( value: e2, locals: &__locals )
        __args[2] = JNIType.toJava( value: e3, locals: &__locals )
        __args[3] = JNIType.toJava( value: e4, locals: &__locals )
        __args[4] = JNIType.toJava( value: e5, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/EnumSet", classCache: &EnumSetJNIClass, methodName: "of", methodSig: "(Ljava/lang/Enum;Ljava/lang/Enum;Ljava/lang/Enum;Ljava/lang/Enum;Ljava/lang/Enum;)Ljava/util/EnumSet;", methodCache: &of_MethodID_6, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? EnumSet( javaObject: __return ) : nil
    }

    open class func of( _ _e1: java_lang.Enum?, _ _e2: java_lang.Enum?, _ _e3: java_lang.Enum?, _ _e4: java_lang.Enum?, _ _e5: java_lang.Enum? ) -> EnumSet! {
        return of( e1: _e1, e2: _e2, e3: _e3, e4: _e4, e5: _e5 )
    }

    /// public static java.util.EnumSet java.util.EnumSet.of(java.lang.Enum,java.lang.Enum[])

    private static var of_MethodID_7: jmethodID?

    open class func of( first: java_lang.Enum?, rest: [Enum]? ) -> EnumSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: first, locals: &__locals )
        __args[1] = JNIType.toJava( value: rest, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/EnumSet", classCache: &EnumSetJNIClass, methodName: "of", methodSig: "(Ljava/lang/Enum;[Ljava/lang/Enum;)Ljava/util/EnumSet;", methodCache: &of_MethodID_7, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? EnumSet( javaObject: __return ) : nil
    }

    open class func of( _ _first: java_lang.Enum?, _ _rest: [Enum]? ) -> EnumSet! {
        return of( first: _first, rest: _rest )
    }

    /// public static java.util.EnumSet java.util.EnumSet.of(java.lang.Enum)

    private static var of_MethodID_8: jmethodID?

    open class func of( e: java_lang.Enum? ) -> EnumSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: e, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/EnumSet", classCache: &EnumSetJNIClass, methodName: "of", methodSig: "(Ljava/lang/Enum;)Ljava/util/EnumSet;", methodCache: &of_MethodID_8, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? EnumSet( javaObject: __return ) : nil
    }

    open class func of( _ _e: java_lang.Enum? ) -> EnumSet! {
        return of( e: _e )
    }

    /// public static java.util.EnumSet java.util.EnumSet.of(java.lang.Enum,java.lang.Enum)

    private static var of_MethodID_9: jmethodID?

    open class func of( e1: java_lang.Enum?, e2: java_lang.Enum? ) -> EnumSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: e1, locals: &__locals )
        __args[1] = JNIType.toJava( value: e2, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/EnumSet", classCache: &EnumSetJNIClass, methodName: "of", methodSig: "(Ljava/lang/Enum;Ljava/lang/Enum;)Ljava/util/EnumSet;", methodCache: &of_MethodID_9, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? EnumSet( javaObject: __return ) : nil
    }

    open class func of( _ _e1: java_lang.Enum?, _ _e2: java_lang.Enum? ) -> EnumSet! {
        return of( e1: _e1, e2: _e2 )
    }

    /// public static java.util.EnumSet java.util.EnumSet.of(java.lang.Enum,java.lang.Enum,java.lang.Enum)

    private static var of_MethodID_10: jmethodID?

    open class func of( e1: java_lang.Enum?, e2: java_lang.Enum?, e3: java_lang.Enum? ) -> EnumSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: e1, locals: &__locals )
        __args[1] = JNIType.toJava( value: e2, locals: &__locals )
        __args[2] = JNIType.toJava( value: e3, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/EnumSet", classCache: &EnumSetJNIClass, methodName: "of", methodSig: "(Ljava/lang/Enum;Ljava/lang/Enum;Ljava/lang/Enum;)Ljava/util/EnumSet;", methodCache: &of_MethodID_10, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? EnumSet( javaObject: __return ) : nil
    }

    open class func of( _ _e1: java_lang.Enum?, _ _e2: java_lang.Enum?, _ _e3: java_lang.Enum? ) -> EnumSet! {
        return of( e1: _e1, e2: _e2, e3: _e3 )
    }

    /// java.lang.Object java.util.EnumSet.writeReplace()

    /// abstract void java.util.EnumSet.complement()

    /// public static java.util.EnumSet java.util.EnumSet.range(java.lang.Enum,java.lang.Enum)

    private static var range_MethodID_11: jmethodID?

    open class func range( from: java_lang.Enum?, to: java_lang.Enum? ) -> EnumSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: from, locals: &__locals )
        __args[1] = JNIType.toJava( value: to, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/EnumSet", classCache: &EnumSetJNIClass, methodName: "range", methodSig: "(Ljava/lang/Enum;Ljava/lang/Enum;)Ljava/util/EnumSet;", methodCache: &range_MethodID_11, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? EnumSet( javaObject: __return ) : nil
    }

    open class func range( _ _from: java_lang.Enum?, _ _to: java_lang.Enum? ) -> EnumSet! {
        return range( from: _from, to: _to )
    }

    /// final void java.util.EnumSet.typeCheck(java.lang.Enum)

    /// public static java.util.EnumSet java.util.EnumSet.noneOf(java.lang.Class)

    private static var noneOf_MethodID_12: jmethodID?

    open class func noneOf( elementType: java_swift.JavaClass? ) -> EnumSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: elementType, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/EnumSet", classCache: &EnumSetJNIClass, methodName: "noneOf", methodSig: "(Ljava/lang/Class;)Ljava/util/EnumSet;", methodCache: &noneOf_MethodID_12, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? EnumSet( javaObject: __return ) : nil
    }

    open class func noneOf( _ _elementType: java_swift.JavaClass? ) -> EnumSet! {
        return noneOf( elementType: _elementType )
    }

    /// public static java.util.EnumSet java.util.EnumSet.allOf(java.lang.Class)

    private static var allOf_MethodID_13: jmethodID?

    open class func allOf( elementType: java_swift.JavaClass? ) -> EnumSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: elementType, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/EnumSet", classCache: &EnumSetJNIClass, methodName: "allOf", methodSig: "(Ljava/lang/Class;)Ljava/util/EnumSet;", methodCache: &allOf_MethodID_13, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? EnumSet( javaObject: __return ) : nil
    }

    open class func allOf( _ _elementType: java_swift.JavaClass? ) -> EnumSet! {
        return allOf( elementType: _elementType )
    }

    /// public static java.util.EnumSet java.util.EnumSet.complementOf(java.util.EnumSet)

    private static var complementOf_MethodID_14: jmethodID?

    open class func complementOf( s: EnumSet? ) -> EnumSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: s, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/EnumSet", classCache: &EnumSetJNIClass, methodName: "complementOf", methodSig: "(Ljava/util/EnumSet;)Ljava/util/EnumSet;", methodCache: &complementOf_MethodID_14, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? EnumSet( javaObject: __return ) : nil
    }

    open class func complementOf( _ _s: EnumSet? ) -> EnumSet! {
        return complementOf( s: _s )
    }

    /// abstract void java.util.EnumSet.addRange(java.lang.Enum,java.lang.Enum)

    /// private static java.lang.Enum[] java.util.EnumSet.getUniverse(java.lang.Class)

}

