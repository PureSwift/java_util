
import java_swift
import java_lang

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// JAVA_HOME: /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home ///
/// Tue Dec 20 11:29:52 GMT 2016 ///

/// class java.util.concurrent.locks.AbstractQueuedLongSynchronizer ///

open class AbstractQueuedLongSynchronizer: AbstractOwnableSynchronizer {

    public convenience init?( casting object: java_lang.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        if !object.validDownCast( toJavaClass: "java.util.concurrent.locks.AbstractQueuedLongSynchronizer", file, line ) {
            return nil
        }
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var AbstractQueuedLongSynchronizerJNIClass: jclass?

    /// private static final long java.util.concurrent.locks.AbstractQueuedLongSynchronizer.serialVersionUID

    /// private transient volatile java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node java.util.concurrent.locks.AbstractQueuedLongSynchronizer.head

    /// private transient volatile java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node java.util.concurrent.locks.AbstractQueuedLongSynchronizer.tail

    /// private volatile long java.util.concurrent.locks.AbstractQueuedLongSynchronizer.state

    /// static final long java.util.concurrent.locks.AbstractQueuedLongSynchronizer.spinForTimeoutThreshold

    /// private static final sun.misc.Unsafe java.util.concurrent.locks.AbstractQueuedLongSynchronizer.unsafe

    /// private static final long java.util.concurrent.locks.AbstractQueuedLongSynchronizer.stateOffset

    /// private static final long java.util.concurrent.locks.AbstractQueuedLongSynchronizer.headOffset

    /// private static final long java.util.concurrent.locks.AbstractQueuedLongSynchronizer.tailOffset

    /// private static final long java.util.concurrent.locks.AbstractQueuedLongSynchronizer.waitStatusOffset

    /// private static final long java.util.concurrent.locks.AbstractQueuedLongSynchronizer.nextOffset

    /// private static final long java.util.concurrent.locks.AbstractOwnableSynchronizer.serialVersionUID

    /// private transient java.lang.Thread java.util.concurrent.locks.AbstractOwnableSynchronizer.exclusiveOwnerThread

    /// protected java.util.concurrent.locks.AbstractQueuedLongSynchronizer()

    private static var new_MethodID_1: jmethodID?

    public convenience init() {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __object = JNIMethod.NewObject( className: "java/util/concurrent/locks/AbstractQueuedLongSynchronizer", classCache: &AbstractQueuedLongSynchronizer.AbstractQueuedLongSynchronizerJNIClass, methodSig: "()V", methodCache: &AbstractQueuedLongSynchronizer.new_MethodID_1, args: &__args, locals: &__locals )
        self.init( javaObject: __object )
        JNI.DeleteLocalRef( __object )
    }

    /// public java.lang.String java.util.concurrent.locks.AbstractQueuedLongSynchronizer.toString()

    /// static void java.util.concurrent.locks.AbstractQueuedLongSynchronizer.access$000()

    /// protected final long java.util.concurrent.locks.AbstractQueuedLongSynchronizer.getState()

    private static var getState_MethodID_2: jmethodID?

    open func getState() -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "getState", methodSig: "()J", methodCache: &AbstractQueuedLongSynchronizer.getState_MethodID_2, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int64(), from: __return )
    }


    /// protected final void java.util.concurrent.locks.AbstractQueuedLongSynchronizer.setState(long)

    private static var setState_MethodID_3: jmethodID?

    open func setState( arg0: Int64 ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setState", methodSig: "(J)V", methodCache: &AbstractQueuedLongSynchronizer.setState_MethodID_3, args: &__args, locals: &__locals )
    }

    open func setState( _ _arg0: Int64 ) {
        setState( arg0: _arg0 )
    }

    /// public final void java.util.concurrent.locks.AbstractQueuedLongSynchronizer.acquire(long)

    private static var acquire_MethodID_4: jmethodID?

    open func acquire( arg0: Int64 ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "acquire", methodSig: "(J)V", methodCache: &AbstractQueuedLongSynchronizer.acquire_MethodID_4, args: &__args, locals: &__locals )
    }

    open func acquire( _ _arg0: Int64 ) {
        acquire( arg0: _arg0 )
    }

    /// public final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.release(long)

    private static var release_MethodID_5: jmethodID?

    open func release( arg0: Int64 ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "release", methodSig: "(J)Z", methodCache: &AbstractQueuedLongSynchronizer.release_MethodID_5, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func release( _ _arg0: Int64 ) -> Bool {
        return release( arg0: _arg0 )
    }

    /// public final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.hasQueuedThreads()

    private static var hasQueuedThreads_MethodID_6: jmethodID?

    open func hasQueuedThreads() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "hasQueuedThreads", methodSig: "()Z", methodCache: &AbstractQueuedLongSynchronizer.hasQueuedThreads_MethodID_6, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public final int java.util.concurrent.locks.AbstractQueuedLongSynchronizer.getQueueLength()

    private static var getQueueLength_MethodID_7: jmethodID?

    open func getQueueLength() -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getQueueLength", methodSig: "()I", methodCache: &AbstractQueuedLongSynchronizer.getQueueLength_MethodID_7, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }


    /// public final java.util.Collection java.util.concurrent.locks.AbstractQueuedLongSynchronizer.getQueuedThreads()

    private static var getQueuedThreads_MethodID_8: jmethodID?

    open func getQueuedThreads() -> Collection! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getQueuedThreads", methodSig: "()Ljava/util/Collection;", methodCache: &AbstractQueuedLongSynchronizer.getQueuedThreads_MethodID_8, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectionForward( javaObject: __return ) : nil
    }


    /// public final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.hasWaiters(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject)

    private static var hasWaiters_MethodID_9: jmethodID?

    open func hasWaiters( arg0: /* java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject */ UnclassedObject? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "hasWaiters", methodSig: "(Ljava/util/concurrent/locks/AbstractQueuedLongSynchronizer$ConditionObject;)Z", methodCache: &AbstractQueuedLongSynchronizer.hasWaiters_MethodID_9, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func hasWaiters( _ _arg0: /* java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject */ UnclassedObject? ) -> Bool {
        return hasWaiters( arg0: _arg0 )
    }

    /// public final int java.util.concurrent.locks.AbstractQueuedLongSynchronizer.getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject)

    private static var getWaitQueueLength_MethodID_10: jmethodID?

    open func getWaitQueueLength( arg0: /* java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject */ UnclassedObject? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getWaitQueueLength", methodSig: "(Ljava/util/concurrent/locks/AbstractQueuedLongSynchronizer$ConditionObject;)I", methodCache: &AbstractQueuedLongSynchronizer.getWaitQueueLength_MethodID_10, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open func getWaitQueueLength( _ _arg0: /* java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject */ UnclassedObject? ) -> Int {
        return getWaitQueueLength( arg0: _arg0 )
    }

    /// public final java.util.Collection java.util.concurrent.locks.AbstractQueuedLongSynchronizer.getWaitingThreads(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject)

    private static var getWaitingThreads_MethodID_11: jmethodID?

    open func getWaitingThreads( arg0: /* java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject */ UnclassedObject? ) -> Collection! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getWaitingThreads", methodSig: "(Ljava/util/concurrent/locks/AbstractQueuedLongSynchronizer$ConditionObject;)Ljava/util/Collection;", methodCache: &AbstractQueuedLongSynchronizer.getWaitingThreads_MethodID_11, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectionForward( javaObject: __return ) : nil
    }

    open func getWaitingThreads( _ _arg0: /* java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject */ UnclassedObject? ) -> Collection! {
        return getWaitingThreads( arg0: _arg0 )
    }

    /// public final void java.util.concurrent.locks.AbstractQueuedLongSynchronizer.acquireInterruptibly(long) throws java.lang.InterruptedException

    private static var acquireInterruptibly_MethodID_12: jmethodID?

    open func acquireInterruptibly( arg0: Int64 ) throws /* java.lang.InterruptedException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "acquireInterruptibly", methodSig: "(J)V", methodCache: &AbstractQueuedLongSynchronizer.acquireInterruptibly_MethodID_12, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.InterruptedException( javaObject: throwable )
        }
    }

    open func acquireInterruptibly( _ _arg0: Int64 ) throws /* java.lang.InterruptedException */ {
        try acquireInterruptibly( arg0: _arg0 )
    }

    /// public final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.tryAcquireNanos(long,long) throws java.lang.InterruptedException

    private static var tryAcquireNanos_MethodID_13: jmethodID?

    open func tryAcquireNanos( arg0: Int64, arg1: Int64 ) throws /* java.lang.InterruptedException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "tryAcquireNanos", methodSig: "(JJ)Z", methodCache: &AbstractQueuedLongSynchronizer.tryAcquireNanos_MethodID_13, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.InterruptedException( javaObject: throwable )
        }
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func tryAcquireNanos( _ _arg0: Int64, _ _arg1: Int64 ) throws /* java.lang.InterruptedException */ -> Bool {
        return try tryAcquireNanos( arg0: _arg0, arg1: _arg1 )
    }

    /// protected boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.isHeldExclusively()

    private static var isHeldExclusively_MethodID_14: jmethodID?

    open func isHeldExclusively() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isHeldExclusively", methodSig: "()Z", methodCache: &AbstractQueuedLongSynchronizer.isHeldExclusively_MethodID_14, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.isQueued(java.lang.Thread)

    private static var isQueued_MethodID_15: jmethodID?

    open func isQueued( arg0: java_lang.Thread? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isQueued", methodSig: "(Ljava/lang/Thread;)Z", methodCache: &AbstractQueuedLongSynchronizer.isQueued_MethodID_15, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func isQueued( _ _arg0: java_lang.Thread? ) -> Bool {
        return isQueued( arg0: _arg0 )
    }

    /// protected boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.tryAcquire(long)

    private static var tryAcquire_MethodID_16: jmethodID?

    open func tryAcquire( arg0: Int64 ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "tryAcquire", methodSig: "(J)Z", methodCache: &AbstractQueuedLongSynchronizer.tryAcquire_MethodID_16, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func tryAcquire( _ _arg0: Int64 ) -> Bool {
        return tryAcquire( arg0: _arg0 )
    }

    /// protected final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.compareAndSetState(long,long)

    private static var compareAndSetState_MethodID_17: jmethodID?

    open func compareAndSetState( arg0: Int64, arg1: Int64 ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "compareAndSetState", methodSig: "(JJ)Z", methodCache: &AbstractQueuedLongSynchronizer.compareAndSetState_MethodID_17, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func compareAndSetState( _ _arg0: Int64, _ _arg1: Int64 ) -> Bool {
        return compareAndSetState( arg0: _arg0, arg1: _arg1 )
    }

    /// protected boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.tryRelease(long)

    private static var tryRelease_MethodID_18: jmethodID?

    open func tryRelease( arg0: Int64 ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "tryRelease", methodSig: "(J)Z", methodCache: &AbstractQueuedLongSynchronizer.tryRelease_MethodID_18, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func tryRelease( _ _arg0: Int64 ) -> Bool {
        return tryRelease( arg0: _arg0 )
    }

    /// private java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node java.util.concurrent.locks.AbstractQueuedLongSynchronizer.enq(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)

    /// private java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node java.util.concurrent.locks.AbstractQueuedLongSynchronizer.addWaiter(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)

    /// private void java.util.concurrent.locks.AbstractQueuedLongSynchronizer.setHead(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)

    /// private void java.util.concurrent.locks.AbstractQueuedLongSynchronizer.unparkSuccessor(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)

    /// private void java.util.concurrent.locks.AbstractQueuedLongSynchronizer.doReleaseShared()

    /// private void java.util.concurrent.locks.AbstractQueuedLongSynchronizer.setHeadAndPropagate(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node,long)

    /// private void java.util.concurrent.locks.AbstractQueuedLongSynchronizer.cancelAcquire(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)

    /// private static boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.shouldParkAfterFailedAcquire(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node,java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)

    /// private static void java.util.concurrent.locks.AbstractQueuedLongSynchronizer.selfInterrupt()

    /// private final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.parkAndCheckInterrupt()

    /// final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.acquireQueued(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node,long)

    /// private void java.util.concurrent.locks.AbstractQueuedLongSynchronizer.doAcquireInterruptibly(long) throws java.lang.InterruptedException

    /// private boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.doAcquireNanos(long,long) throws java.lang.InterruptedException

    /// private void java.util.concurrent.locks.AbstractQueuedLongSynchronizer.doAcquireShared(long)

    /// private void java.util.concurrent.locks.AbstractQueuedLongSynchronizer.doAcquireSharedInterruptibly(long) throws java.lang.InterruptedException

    /// private boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.doAcquireSharedNanos(long,long) throws java.lang.InterruptedException

    /// protected long java.util.concurrent.locks.AbstractQueuedLongSynchronizer.tryAcquireShared(long)

    private static var tryAcquireShared_MethodID_19: jmethodID?

    open func tryAcquireShared( arg0: Int64 ) -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "tryAcquireShared", methodSig: "(J)J", methodCache: &AbstractQueuedLongSynchronizer.tryAcquireShared_MethodID_19, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int64(), from: __return )
    }

    open func tryAcquireShared( _ _arg0: Int64 ) -> Int64 {
        return tryAcquireShared( arg0: _arg0 )
    }

    /// protected boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.tryReleaseShared(long)

    private static var tryReleaseShared_MethodID_20: jmethodID?

    open func tryReleaseShared( arg0: Int64 ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "tryReleaseShared", methodSig: "(J)Z", methodCache: &AbstractQueuedLongSynchronizer.tryReleaseShared_MethodID_20, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func tryReleaseShared( _ _arg0: Int64 ) -> Bool {
        return tryReleaseShared( arg0: _arg0 )
    }

    /// public final void java.util.concurrent.locks.AbstractQueuedLongSynchronizer.acquireShared(long)

    private static var acquireShared_MethodID_21: jmethodID?

    open func acquireShared( arg0: Int64 ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "acquireShared", methodSig: "(J)V", methodCache: &AbstractQueuedLongSynchronizer.acquireShared_MethodID_21, args: &__args, locals: &__locals )
    }

    open func acquireShared( _ _arg0: Int64 ) {
        acquireShared( arg0: _arg0 )
    }

    /// public final void java.util.concurrent.locks.AbstractQueuedLongSynchronizer.acquireSharedInterruptibly(long) throws java.lang.InterruptedException

    private static var acquireSharedInterruptibly_MethodID_22: jmethodID?

    open func acquireSharedInterruptibly( arg0: Int64 ) throws /* java.lang.InterruptedException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "acquireSharedInterruptibly", methodSig: "(J)V", methodCache: &AbstractQueuedLongSynchronizer.acquireSharedInterruptibly_MethodID_22, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.InterruptedException( javaObject: throwable )
        }
    }

    open func acquireSharedInterruptibly( _ _arg0: Int64 ) throws /* java.lang.InterruptedException */ {
        try acquireSharedInterruptibly( arg0: _arg0 )
    }

    /// public final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.tryAcquireSharedNanos(long,long) throws java.lang.InterruptedException

    private static var tryAcquireSharedNanos_MethodID_23: jmethodID?

    open func tryAcquireSharedNanos( arg0: Int64, arg1: Int64 ) throws /* java.lang.InterruptedException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "tryAcquireSharedNanos", methodSig: "(JJ)Z", methodCache: &AbstractQueuedLongSynchronizer.tryAcquireSharedNanos_MethodID_23, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.InterruptedException( javaObject: throwable )
        }
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func tryAcquireSharedNanos( _ _arg0: Int64, _ _arg1: Int64 ) throws /* java.lang.InterruptedException */ -> Bool {
        return try tryAcquireSharedNanos( arg0: _arg0, arg1: _arg1 )
    }

    /// public final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.releaseShared(long)

    private static var releaseShared_MethodID_24: jmethodID?

    open func releaseShared( arg0: Int64 ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "releaseShared", methodSig: "(J)Z", methodCache: &AbstractQueuedLongSynchronizer.releaseShared_MethodID_24, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func releaseShared( _ _arg0: Int64 ) -> Bool {
        return releaseShared( arg0: _arg0 )
    }

    /// public final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.hasContended()

    private static var hasContended_MethodID_25: jmethodID?

    open func hasContended() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "hasContended", methodSig: "()Z", methodCache: &AbstractQueuedLongSynchronizer.hasContended_MethodID_25, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public final java.lang.Thread java.util.concurrent.locks.AbstractQueuedLongSynchronizer.getFirstQueuedThread()

    private static var getFirstQueuedThread_MethodID_26: jmethodID?

    open func getFirstQueuedThread() -> java_lang.Thread! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getFirstQueuedThread", methodSig: "()Ljava/lang/Thread;", methodCache: &AbstractQueuedLongSynchronizer.getFirstQueuedThread_MethodID_26, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_lang.Thread( javaObject: __return ) : nil
    }


    /// private java.lang.Thread java.util.concurrent.locks.AbstractQueuedLongSynchronizer.fullGetFirstQueuedThread()

    /// final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.apparentlyFirstQueuedIsExclusive()

    /// final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.isFirst(java.lang.Thread)

    /// final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.fullIsFirst(java.lang.Thread)

    /// public final java.util.Collection java.util.concurrent.locks.AbstractQueuedLongSynchronizer.getExclusiveQueuedThreads()

    private static var getExclusiveQueuedThreads_MethodID_27: jmethodID?

    open func getExclusiveQueuedThreads() -> Collection! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getExclusiveQueuedThreads", methodSig: "()Ljava/util/Collection;", methodCache: &AbstractQueuedLongSynchronizer.getExclusiveQueuedThreads_MethodID_27, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectionForward( javaObject: __return ) : nil
    }


    /// public final java.util.Collection java.util.concurrent.locks.AbstractQueuedLongSynchronizer.getSharedQueuedThreads()

    private static var getSharedQueuedThreads_MethodID_28: jmethodID?

    open func getSharedQueuedThreads() -> Collection! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getSharedQueuedThreads", methodSig: "()Ljava/util/Collection;", methodCache: &AbstractQueuedLongSynchronizer.getSharedQueuedThreads_MethodID_28, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectionForward( javaObject: __return ) : nil
    }


    /// final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.isOnSyncQueue(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)

    /// private boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.findNodeFromTail(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)

    /// final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.transferForSignal(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)

    /// final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.transferAfterCancelledWait(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)

    /// final long java.util.concurrent.locks.AbstractQueuedLongSynchronizer.fullyRelease(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)

    /// public final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.owns(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject)

    private static var owns_MethodID_29: jmethodID?

    open func owns( arg0: /* java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject */ UnclassedObject? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "owns", methodSig: "(Ljava/util/concurrent/locks/AbstractQueuedLongSynchronizer$ConditionObject;)Z", methodCache: &AbstractQueuedLongSynchronizer.owns_MethodID_29, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func owns( _ _arg0: /* java.util.concurrent.locks.AbstractQueuedLongSynchronizer$ConditionObject */ UnclassedObject? ) -> Bool {
        return owns( arg0: _arg0 )
    }

    /// private final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.compareAndSetHead(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)

    /// private final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.compareAndSetTail(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node,java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)

    /// private static final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.compareAndSetWaitStatus(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node,int,int)

    /// private static final boolean java.util.concurrent.locks.AbstractQueuedLongSynchronizer.compareAndSetNext(java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node,java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node,java.util.concurrent.locks.AbstractQueuedLongSynchronizer$Node)

}
