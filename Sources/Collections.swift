
import java_swift
import java_lang

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// JAVA_HOME: /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home ///
/// Tue Dec 20 11:30:12 GMT 2016 ///

/// class java.util.Collections ///

open class Collections: java_lang.JavaObject {

    public convenience init?( casting object: java_lang.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        if !object.validDownCast( toJavaClass: "java.util.Collections", file, line ) {
            return nil
        }
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var CollectionsJNIClass: jclass?

    /// private static final int java.util.Collections.BINARYSEARCH_THRESHOLD

    /// private static final int java.util.Collections.REVERSE_THRESHOLD

    /// private static final int java.util.Collections.SHUFFLE_THRESHOLD

    /// private static final int java.util.Collections.FILL_THRESHOLD

    /// private static final int java.util.Collections.ROTATE_THRESHOLD

    /// private static final int java.util.Collections.COPY_THRESHOLD

    /// private static final int java.util.Collections.REPLACEALL_THRESHOLD

    /// private static final int java.util.Collections.INDEXOFSUBLIST_THRESHOLD

    /// private static java.util.Random java.util.Collections.r

    /// public static final java.util.Set java.util.Collections.EMPTY_SET

    private static var EMPTY_SET_FieldID: jfieldID?

    open static var EMPTY_SET: JavaSet! {
        get {
            let __value = JNIField.GetStaticObjectField( fieldName: "EMPTY_SET", fieldType: "Ljava/util/Set;", fieldCache: &EMPTY_SET_FieldID, className: "java/util/Collections", classCache: &CollectionsJNIClass )
            return __value != nil ? JavaSetForward( javaObject: __value ) : nil
        }
    }

    /// public static final java.util.List java.util.Collections.EMPTY_LIST

    private static var EMPTY_LIST_FieldID: jfieldID?

    open static var EMPTY_LIST: List! {
        get {
            let __value = JNIField.GetStaticObjectField( fieldName: "EMPTY_LIST", fieldType: "Ljava/util/List;", fieldCache: &EMPTY_LIST_FieldID, className: "java/util/Collections", classCache: &CollectionsJNIClass )
            return __value != nil ? ListForward( javaObject: __value ) : nil
        }
    }

    /// public static final java.util.Map java.util.Collections.EMPTY_MAP

    private static var EMPTY_MAP_FieldID: jfieldID?

    open static var EMPTY_MAP: Map! {
        get {
            let __value = JNIField.GetStaticObjectField( fieldName: "EMPTY_MAP", fieldType: "Ljava/util/Map;", fieldCache: &EMPTY_MAP_FieldID, className: "java/util/Collections", classCache: &CollectionsJNIClass )
            return __value != nil ? MapForward( javaObject: __value ) : nil
        }
    }

    /// private static final java.util.Comparator java.util.Collections.REVERSE_ORDER

    /// private java.util.Collections()

    /// private static java.lang.Object java.util.Collections.get(java.util.ListIterator,int)

    /// public static java.lang.Object java.util.Collections.min(java.util.Collection)

    private static var min_MethodID_1: jmethodID?

    open class func min( arg0: Collection? ) -> java_lang.JavaObject! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "min", methodSig: "(Ljava/util/Collection;)Ljava/lang/Object;", methodCache: &min_MethodID_1, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_lang.JavaObject( javaObject: __return ) : nil
    }

    open class func min( _ _arg0: Collection? ) -> java_lang.JavaObject! {
        return min( arg0: _arg0 )
    }

    /// public static java.lang.Object java.util.Collections.min(java.util.Collection,java.util.Comparator)

    private static var min_MethodID_2: jmethodID?

    open class func min( arg0: Collection?, arg1: JavaComparator? ) -> java_lang.JavaObject! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = jvalue( l: arg1?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "min", methodSig: "(Ljava/util/Collection;Ljava/util/Comparator;)Ljava/lang/Object;", methodCache: &min_MethodID_2, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_lang.JavaObject( javaObject: __return ) : nil
    }

    open class func min( _ _arg0: Collection?, _ _arg1: JavaComparator? ) -> java_lang.JavaObject! {
        return min( arg0: _arg0, arg1: _arg1 )
    }

    /// public static java.lang.Object java.util.Collections.max(java.util.Collection)

    private static var max_MethodID_3: jmethodID?

    open class func max( arg0: Collection? ) -> java_lang.JavaObject! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "max", methodSig: "(Ljava/util/Collection;)Ljava/lang/Object;", methodCache: &max_MethodID_3, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_lang.JavaObject( javaObject: __return ) : nil
    }

    open class func max( _ _arg0: Collection? ) -> java_lang.JavaObject! {
        return max( arg0: _arg0 )
    }

    /// public static java.lang.Object java.util.Collections.max(java.util.Collection,java.util.Comparator)

    private static var max_MethodID_4: jmethodID?

    open class func max( arg0: Collection?, arg1: JavaComparator? ) -> java_lang.JavaObject! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = jvalue( l: arg1?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "max", methodSig: "(Ljava/util/Collection;Ljava/util/Comparator;)Ljava/lang/Object;", methodCache: &max_MethodID_4, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_lang.JavaObject( javaObject: __return ) : nil
    }

    open class func max( _ _arg0: Collection?, _ _arg1: JavaComparator? ) -> java_lang.JavaObject! {
        return max( arg0: _arg0, arg1: _arg1 )
    }

    /// public static boolean java.util.Collections.replaceAll(java.util.List,java.lang.Object,java.lang.Object)

    private static var replaceAll_MethodID_5: jmethodID?

    open class func replaceAll( arg0: List?, arg1: java_lang.JavaObject?, arg2: java_lang.JavaObject? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "replaceAll", methodSig: "(Ljava/util/List;Ljava/lang/Object;Ljava/lang/Object;)Z", methodCache: &replaceAll_MethodID_5, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open class func replaceAll( _ _arg0: List?, _ _arg1: java_lang.JavaObject?, _ _arg2: java_lang.JavaObject? ) -> Bool {
        return replaceAll( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static boolean java.util.Collections.addAll(java.util.Collection,java.lang.Object[])

    private static var addAll_MethodID_6: jmethodID?

    open class func addAll( arg0: Collection?, arg1: [JavaObject]? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "addAll", methodSig: "(Ljava/util/Collection;[Ljava/lang/Object;)Z", methodCache: &addAll_MethodID_6, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open class func addAll( _ _arg0: Collection?, _ _arg1: [JavaObject]? ) -> Bool {
        return addAll( arg0: _arg0, arg1: _arg1 )
    }

    /// static boolean java.util.Collections.access$000(java.lang.Object,java.lang.Object)

    /// public static java.util.ArrayList java.util.Collections.list(java.util.Enumeration)

    private static var list_MethodID_7: jmethodID?

    open class func list( arg0: Enumeration? ) -> ArrayList! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "list", methodSig: "(Ljava/util/Enumeration;)Ljava/util/ArrayList;", methodCache: &list_MethodID_7, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ArrayList( javaObject: __return ) : nil
    }

    open class func list( _ _arg0: Enumeration? ) -> ArrayList! {
        return list( arg0: _arg0 )
    }

    /// public static java.util.Set java.util.Collections.synchronizedSet(java.util.Set)

    private static var synchronizedSet_MethodID_8: jmethodID?

    open class func synchronizedSet( arg0: JavaSet? ) -> JavaSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "synchronizedSet", methodSig: "(Ljava/util/Set;)Ljava/util/Set;", methodCache: &synchronizedSet_MethodID_8, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? JavaSetForward( javaObject: __return ) : nil
    }

    open class func synchronizedSet( _ _arg0: JavaSet? ) -> JavaSet! {
        return synchronizedSet( arg0: _arg0 )
    }

    /// static java.util.Set java.util.Collections.synchronizedSet(java.util.Set,java.lang.Object)

    /// public static java.util.Collection java.util.Collections.synchronizedCollection(java.util.Collection)

    private static var synchronizedCollection_MethodID_9: jmethodID?

    open class func synchronizedCollection( arg0: Collection? ) -> Collection! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "synchronizedCollection", methodSig: "(Ljava/util/Collection;)Ljava/util/Collection;", methodCache: &synchronizedCollection_MethodID_9, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectionForward( javaObject: __return ) : nil
    }

    open class func synchronizedCollection( _ _arg0: Collection? ) -> Collection! {
        return synchronizedCollection( arg0: _arg0 )
    }

    /// static java.util.Collection java.util.Collections.synchronizedCollection(java.util.Collection,java.lang.Object)

    /// public static void java.util.Collections.copy(java.util.List,java.util.List)

    private static var copy_MethodID_10: jmethodID?

    open class func copy( arg0: List?, arg1: List? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = jvalue( l: arg1?.localJavaObject( &__locals ) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "copy", methodSig: "(Ljava/util/List;Ljava/util/List;)V", methodCache: &copy_MethodID_10, args: &__args, locals: &__locals )
    }

    open class func copy( _ _arg0: List?, _ _arg1: List? ) {
        copy( arg0: _arg0, arg1: _arg1 )
    }

    /// public static void java.util.Collections.reverse(java.util.List)

    private static var reverse_MethodID_11: jmethodID?

    open class func reverse( arg0: List? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "reverse", methodSig: "(Ljava/util/List;)V", methodCache: &reverse_MethodID_11, args: &__args, locals: &__locals )
    }

    open class func reverse( _ _arg0: List? ) {
        reverse( arg0: _arg0 )
    }

    /// private static boolean java.util.Collections.eq(java.lang.Object,java.lang.Object)

    /// public static void java.util.Collections.fill(java.util.List,java.lang.Object)

    private static var fill_MethodID_12: jmethodID?

    open class func fill( arg0: List?, arg1: java_lang.JavaObject? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "fill", methodSig: "(Ljava/util/List;Ljava/lang/Object;)V", methodCache: &fill_MethodID_12, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: List?, _ _arg1: java_lang.JavaObject? ) {
        fill( arg0: _arg0, arg1: _arg1 )
    }

    /// public static java.util.Map java.util.Collections.synchronizedMap(java.util.Map)

    private static var synchronizedMap_MethodID_13: jmethodID?

    open class func synchronizedMap( arg0: Map? ) -> Map! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "synchronizedMap", methodSig: "(Ljava/util/Map;)Ljava/util/Map;", methodCache: &synchronizedMap_MethodID_13, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? MapForward( javaObject: __return ) : nil
    }

    open class func synchronizedMap( _ _arg0: Map? ) -> Map! {
        return synchronizedMap( arg0: _arg0 )
    }

    /// public static void java.util.Collections.sort(java.util.List)

    private static var sort_MethodID_14: jmethodID?

    open class func sort( arg0: List? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "sort", methodSig: "(Ljava/util/List;)V", methodCache: &sort_MethodID_14, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: List? ) {
        sort( arg0: _arg0 )
    }

    /// public static void java.util.Collections.sort(java.util.List,java.util.Comparator)

    private static var sort_MethodID_15: jmethodID?

    open class func sort( arg0: List?, arg1: JavaComparator? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = jvalue( l: arg1?.localJavaObject( &__locals ) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "sort", methodSig: "(Ljava/util/List;Ljava/util/Comparator;)V", methodCache: &sort_MethodID_15, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: List?, _ _arg1: JavaComparator? ) {
        sort( arg0: _arg0, arg1: _arg1 )
    }

    /// public static int java.util.Collections.binarySearch(java.util.List,java.lang.Object)

    private static var binarySearch_MethodID_16: jmethodID?

    open class func binarySearch( arg0: List?, arg1: java_lang.JavaObject? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "binarySearch", methodSig: "(Ljava/util/List;Ljava/lang/Object;)I", methodCache: &binarySearch_MethodID_16, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: List?, _ _arg1: java_lang.JavaObject? ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1 )
    }

    /// public static int java.util.Collections.binarySearch(java.util.List,java.lang.Object,java.util.Comparator)

    private static var binarySearch_MethodID_17: jmethodID?

    open class func binarySearch( arg0: List?, arg1: java_lang.JavaObject?, arg2: JavaComparator? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = jvalue( l: arg2?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "binarySearch", methodSig: "(Ljava/util/List;Ljava/lang/Object;Ljava/util/Comparator;)I", methodCache: &binarySearch_MethodID_17, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: List?, _ _arg1: java_lang.JavaObject?, _ _arg2: JavaComparator? ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// private static int java.util.Collections.indexedBinarySearch(java.util.List,java.lang.Object)

    /// private static int java.util.Collections.indexedBinarySearch(java.util.List,java.lang.Object,java.util.Comparator)

    /// private static int java.util.Collections.iteratorBinarySearch(java.util.List,java.lang.Object)

    /// private static int java.util.Collections.iteratorBinarySearch(java.util.List,java.lang.Object,java.util.Comparator)

    /// public static void java.util.Collections.shuffle(java.util.List,java.util.Random)

    private static var shuffle_MethodID_18: jmethodID?

    open class func shuffle( arg0: List?, arg1: Random? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "shuffle", methodSig: "(Ljava/util/List;Ljava/util/Random;)V", methodCache: &shuffle_MethodID_18, args: &__args, locals: &__locals )
    }

    open class func shuffle( _ _arg0: List?, _ _arg1: Random? ) {
        shuffle( arg0: _arg0, arg1: _arg1 )
    }

    /// public static void java.util.Collections.shuffle(java.util.List)

    private static var shuffle_MethodID_19: jmethodID?

    open class func shuffle( arg0: List? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "shuffle", methodSig: "(Ljava/util/List;)V", methodCache: &shuffle_MethodID_19, args: &__args, locals: &__locals )
    }

    open class func shuffle( _ _arg0: List? ) {
        shuffle( arg0: _arg0 )
    }

    /// public static void java.util.Collections.swap(java.util.List,int,int)

    private static var swap_MethodID_20: jmethodID?

    open class func swap( arg0: List?, arg1: Int, arg2: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "swap", methodSig: "(Ljava/util/List;II)V", methodCache: &swap_MethodID_20, args: &__args, locals: &__locals )
    }

    open class func swap( _ _arg0: List?, _ _arg1: Int, _ _arg2: Int ) {
        swap( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// private static void java.util.Collections.swap(java.lang.Object[],int,int)

    /// public static void java.util.Collections.rotate(java.util.List,int)

    private static var rotate_MethodID_21: jmethodID?

    open class func rotate( arg0: List?, arg1: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "rotate", methodSig: "(Ljava/util/List;I)V", methodCache: &rotate_MethodID_21, args: &__args, locals: &__locals )
    }

    open class func rotate( _ _arg0: List?, _ _arg1: Int ) {
        rotate( arg0: _arg0, arg1: _arg1 )
    }

    /// private static void java.util.Collections.rotate1(java.util.List,int)

    /// private static void java.util.Collections.rotate2(java.util.List,int)

    /// public static int java.util.Collections.indexOfSubList(java.util.List,java.util.List)

    private static var indexOfSubList_MethodID_22: jmethodID?

    open class func indexOfSubList( arg0: List?, arg1: List? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = jvalue( l: arg1?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "indexOfSubList", methodSig: "(Ljava/util/List;Ljava/util/List;)I", methodCache: &indexOfSubList_MethodID_22, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func indexOfSubList( _ _arg0: List?, _ _arg1: List? ) -> Int {
        return indexOfSubList( arg0: _arg0, arg1: _arg1 )
    }

    /// public static int java.util.Collections.lastIndexOfSubList(java.util.List,java.util.List)

    private static var lastIndexOfSubList_MethodID_23: jmethodID?

    open class func lastIndexOfSubList( arg0: List?, arg1: List? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = jvalue( l: arg1?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "lastIndexOfSubList", methodSig: "(Ljava/util/List;Ljava/util/List;)I", methodCache: &lastIndexOfSubList_MethodID_23, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func lastIndexOfSubList( _ _arg0: List?, _ _arg1: List? ) -> Int {
        return lastIndexOfSubList( arg0: _arg0, arg1: _arg1 )
    }

    /// public static java.util.Collection java.util.Collections.unmodifiableCollection(java.util.Collection)

    private static var unmodifiableCollection_MethodID_24: jmethodID?

    open class func unmodifiableCollection( arg0: Collection? ) -> Collection! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "unmodifiableCollection", methodSig: "(Ljava/util/Collection;)Ljava/util/Collection;", methodCache: &unmodifiableCollection_MethodID_24, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectionForward( javaObject: __return ) : nil
    }

    open class func unmodifiableCollection( _ _arg0: Collection? ) -> Collection! {
        return unmodifiableCollection( arg0: _arg0 )
    }

    /// public static java.util.Set java.util.Collections.unmodifiableSet(java.util.Set)

    private static var unmodifiableSet_MethodID_25: jmethodID?

    open class func unmodifiableSet( arg0: JavaSet? ) -> JavaSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "unmodifiableSet", methodSig: "(Ljava/util/Set;)Ljava/util/Set;", methodCache: &unmodifiableSet_MethodID_25, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? JavaSetForward( javaObject: __return ) : nil
    }

    open class func unmodifiableSet( _ _arg0: JavaSet? ) -> JavaSet! {
        return unmodifiableSet( arg0: _arg0 )
    }

    /// public static java.util.SortedSet java.util.Collections.unmodifiableSortedSet(java.util.SortedSet)

    private static var unmodifiableSortedSet_MethodID_26: jmethodID?

    open class func unmodifiableSortedSet( arg0: SortedSet? ) -> SortedSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "unmodifiableSortedSet", methodSig: "(Ljava/util/SortedSet;)Ljava/util/SortedSet;", methodCache: &unmodifiableSortedSet_MethodID_26, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? SortedSetForward( javaObject: __return ) : nil
    }

    open class func unmodifiableSortedSet( _ _arg0: SortedSet? ) -> SortedSet! {
        return unmodifiableSortedSet( arg0: _arg0 )
    }

    /// public static java.util.List java.util.Collections.unmodifiableList(java.util.List)

    private static var unmodifiableList_MethodID_27: jmethodID?

    open class func unmodifiableList( arg0: List? ) -> List! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "unmodifiableList", methodSig: "(Ljava/util/List;)Ljava/util/List;", methodCache: &unmodifiableList_MethodID_27, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ListForward( javaObject: __return ) : nil
    }

    open class func unmodifiableList( _ _arg0: List? ) -> List! {
        return unmodifiableList( arg0: _arg0 )
    }

    /// public static java.util.Map java.util.Collections.unmodifiableMap(java.util.Map)

    private static var unmodifiableMap_MethodID_28: jmethodID?

    open class func unmodifiableMap( arg0: Map? ) -> Map! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "unmodifiableMap", methodSig: "(Ljava/util/Map;)Ljava/util/Map;", methodCache: &unmodifiableMap_MethodID_28, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? MapForward( javaObject: __return ) : nil
    }

    open class func unmodifiableMap( _ _arg0: Map? ) -> Map! {
        return unmodifiableMap( arg0: _arg0 )
    }

    /// public static java.util.SortedMap java.util.Collections.unmodifiableSortedMap(java.util.SortedMap)

    private static var unmodifiableSortedMap_MethodID_29: jmethodID?

    open class func unmodifiableSortedMap( arg0: SortedMap? ) -> SortedMap! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "unmodifiableSortedMap", methodSig: "(Ljava/util/SortedMap;)Ljava/util/SortedMap;", methodCache: &unmodifiableSortedMap_MethodID_29, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? SortedMapForward( javaObject: __return ) : nil
    }

    open class func unmodifiableSortedMap( _ _arg0: SortedMap? ) -> SortedMap! {
        return unmodifiableSortedMap( arg0: _arg0 )
    }

    /// public static java.util.SortedSet java.util.Collections.synchronizedSortedSet(java.util.SortedSet)

    private static var synchronizedSortedSet_MethodID_30: jmethodID?

    open class func synchronizedSortedSet( arg0: SortedSet? ) -> SortedSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "synchronizedSortedSet", methodSig: "(Ljava/util/SortedSet;)Ljava/util/SortedSet;", methodCache: &synchronizedSortedSet_MethodID_30, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? SortedSetForward( javaObject: __return ) : nil
    }

    open class func synchronizedSortedSet( _ _arg0: SortedSet? ) -> SortedSet! {
        return synchronizedSortedSet( arg0: _arg0 )
    }

    /// static java.util.List java.util.Collections.synchronizedList(java.util.List,java.lang.Object)

    /// public static java.util.List java.util.Collections.synchronizedList(java.util.List)

    private static var synchronizedList_MethodID_31: jmethodID?

    open class func synchronizedList( arg0: List? ) -> List! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "synchronizedList", methodSig: "(Ljava/util/List;)Ljava/util/List;", methodCache: &synchronizedList_MethodID_31, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ListForward( javaObject: __return ) : nil
    }

    open class func synchronizedList( _ _arg0: List? ) -> List! {
        return synchronizedList( arg0: _arg0 )
    }

    /// public static java.util.SortedMap java.util.Collections.synchronizedSortedMap(java.util.SortedMap)

    private static var synchronizedSortedMap_MethodID_32: jmethodID?

    open class func synchronizedSortedMap( arg0: SortedMap? ) -> SortedMap! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "synchronizedSortedMap", methodSig: "(Ljava/util/SortedMap;)Ljava/util/SortedMap;", methodCache: &synchronizedSortedMap_MethodID_32, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? SortedMapForward( javaObject: __return ) : nil
    }

    open class func synchronizedSortedMap( _ _arg0: SortedMap? ) -> SortedMap! {
        return synchronizedSortedMap( arg0: _arg0 )
    }

    /// public static java.util.Collection java.util.Collections.checkedCollection(java.util.Collection,java.lang.Class)

    private static var checkedCollection_MethodID_33: jmethodID?

    open class func checkedCollection( arg0: Collection?, arg1: java_lang.Class? ) -> Collection! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "checkedCollection", methodSig: "(Ljava/util/Collection;Ljava/lang/Class;)Ljava/util/Collection;", methodCache: &checkedCollection_MethodID_33, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectionForward( javaObject: __return ) : nil
    }

    open class func checkedCollection( _ _arg0: Collection?, _ _arg1: java_lang.Class? ) -> Collection! {
        return checkedCollection( arg0: _arg0, arg1: _arg1 )
    }

    /// public static java.util.Set java.util.Collections.checkedSet(java.util.Set,java.lang.Class)

    private static var checkedSet_MethodID_34: jmethodID?

    open class func checkedSet( arg0: JavaSet?, arg1: java_lang.Class? ) -> JavaSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "checkedSet", methodSig: "(Ljava/util/Set;Ljava/lang/Class;)Ljava/util/Set;", methodCache: &checkedSet_MethodID_34, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? JavaSetForward( javaObject: __return ) : nil
    }

    open class func checkedSet( _ _arg0: JavaSet?, _ _arg1: java_lang.Class? ) -> JavaSet! {
        return checkedSet( arg0: _arg0, arg1: _arg1 )
    }

    /// public static java.util.SortedSet java.util.Collections.checkedSortedSet(java.util.SortedSet,java.lang.Class)

    private static var checkedSortedSet_MethodID_35: jmethodID?

    open class func checkedSortedSet( arg0: SortedSet?, arg1: java_lang.Class? ) -> SortedSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "checkedSortedSet", methodSig: "(Ljava/util/SortedSet;Ljava/lang/Class;)Ljava/util/SortedSet;", methodCache: &checkedSortedSet_MethodID_35, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? SortedSetForward( javaObject: __return ) : nil
    }

    open class func checkedSortedSet( _ _arg0: SortedSet?, _ _arg1: java_lang.Class? ) -> SortedSet! {
        return checkedSortedSet( arg0: _arg0, arg1: _arg1 )
    }

    /// public static java.util.List java.util.Collections.checkedList(java.util.List,java.lang.Class)

    private static var checkedList_MethodID_36: jmethodID?

    open class func checkedList( arg0: List?, arg1: java_lang.Class? ) -> List! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "checkedList", methodSig: "(Ljava/util/List;Ljava/lang/Class;)Ljava/util/List;", methodCache: &checkedList_MethodID_36, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ListForward( javaObject: __return ) : nil
    }

    open class func checkedList( _ _arg0: List?, _ _arg1: java_lang.Class? ) -> List! {
        return checkedList( arg0: _arg0, arg1: _arg1 )
    }

    /// public static java.util.Map java.util.Collections.checkedMap(java.util.Map,java.lang.Class,java.lang.Class)

    private static var checkedMap_MethodID_37: jmethodID?

    open class func checkedMap( arg0: Map?, arg1: java_lang.Class?, arg2: java_lang.Class? ) -> Map! {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "checkedMap", methodSig: "(Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)Ljava/util/Map;", methodCache: &checkedMap_MethodID_37, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? MapForward( javaObject: __return ) : nil
    }

    open class func checkedMap( _ _arg0: Map?, _ _arg1: java_lang.Class?, _ _arg2: java_lang.Class? ) -> Map! {
        return checkedMap( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static java.util.SortedMap java.util.Collections.checkedSortedMap(java.util.SortedMap,java.lang.Class,java.lang.Class)

    private static var checkedSortedMap_MethodID_38: jmethodID?

    open class func checkedSortedMap( arg0: SortedMap?, arg1: java_lang.Class?, arg2: java_lang.Class? ) -> SortedMap! {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "checkedSortedMap", methodSig: "(Ljava/util/SortedMap;Ljava/lang/Class;Ljava/lang/Class;)Ljava/util/SortedMap;", methodCache: &checkedSortedMap_MethodID_38, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? SortedMapForward( javaObject: __return ) : nil
    }

    open class func checkedSortedMap( _ _arg0: SortedMap?, _ _arg1: java_lang.Class?, _ _arg2: java_lang.Class? ) -> SortedMap! {
        return checkedSortedMap( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static final java.util.Set java.util.Collections.emptySet()

    private static var emptySet_MethodID_39: jmethodID?

    open class func emptySet() -> JavaSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "emptySet", methodSig: "()Ljava/util/Set;", methodCache: &emptySet_MethodID_39, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? JavaSetForward( javaObject: __return ) : nil
    }


    /// public static final java.util.List java.util.Collections.emptyList()

    private static var emptyList_MethodID_40: jmethodID?

    open class func emptyList() -> List! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "emptyList", methodSig: "()Ljava/util/List;", methodCache: &emptyList_MethodID_40, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ListForward( javaObject: __return ) : nil
    }


    /// public static final java.util.Map java.util.Collections.emptyMap()

    private static var emptyMap_MethodID_41: jmethodID?

    open class func emptyMap() -> Map! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "emptyMap", methodSig: "()Ljava/util/Map;", methodCache: &emptyMap_MethodID_41, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? MapForward( javaObject: __return ) : nil
    }


    /// public static java.util.Set java.util.Collections.singleton(java.lang.Object)

    private static var singleton_MethodID_42: jmethodID?

    open class func singleton( arg0: java_lang.JavaObject? ) -> JavaSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "singleton", methodSig: "(Ljava/lang/Object;)Ljava/util/Set;", methodCache: &singleton_MethodID_42, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? JavaSetForward( javaObject: __return ) : nil
    }

    open class func singleton( _ _arg0: java_lang.JavaObject? ) -> JavaSet! {
        return singleton( arg0: _arg0 )
    }

    /// public static java.util.List java.util.Collections.singletonList(java.lang.Object)

    private static var singletonList_MethodID_43: jmethodID?

    open class func singletonList( arg0: java_lang.JavaObject? ) -> List! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "singletonList", methodSig: "(Ljava/lang/Object;)Ljava/util/List;", methodCache: &singletonList_MethodID_43, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ListForward( javaObject: __return ) : nil
    }

    open class func singletonList( _ _arg0: java_lang.JavaObject? ) -> List! {
        return singletonList( arg0: _arg0 )
    }

    /// public static java.util.Map java.util.Collections.singletonMap(java.lang.Object,java.lang.Object)

    private static var singletonMap_MethodID_44: jmethodID?

    open class func singletonMap( arg0: java_lang.JavaObject?, arg1: java_lang.JavaObject? ) -> Map! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "singletonMap", methodSig: "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/Map;", methodCache: &singletonMap_MethodID_44, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? MapForward( javaObject: __return ) : nil
    }

    open class func singletonMap( _ _arg0: java_lang.JavaObject?, _ _arg1: java_lang.JavaObject? ) -> Map! {
        return singletonMap( arg0: _arg0, arg1: _arg1 )
    }

    /// public static java.util.List java.util.Collections.nCopies(int,java.lang.Object)

    private static var nCopies_MethodID_45: jmethodID?

    open class func nCopies( arg0: Int, arg1: java_lang.JavaObject? ) -> List! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "nCopies", methodSig: "(ILjava/lang/Object;)Ljava/util/List;", methodCache: &nCopies_MethodID_45, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ListForward( javaObject: __return ) : nil
    }

    open class func nCopies( _ _arg0: Int, _ _arg1: java_lang.JavaObject? ) -> List! {
        return nCopies( arg0: _arg0, arg1: _arg1 )
    }

    /// public static java.util.Comparator java.util.Collections.reverseOrder(java.util.Comparator)

    private static var reverseOrder_MethodID_46: jmethodID?

    open class func reverseOrder( arg0: JavaComparator? ) -> JavaComparator! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "reverseOrder", methodSig: "(Ljava/util/Comparator;)Ljava/util/Comparator;", methodCache: &reverseOrder_MethodID_46, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? JavaComparatorForward( javaObject: __return ) : nil
    }

    open class func reverseOrder( _ _arg0: JavaComparator? ) -> JavaComparator! {
        return reverseOrder( arg0: _arg0 )
    }

    /// public static java.util.Comparator java.util.Collections.reverseOrder()

    private static var reverseOrder_MethodID_47: jmethodID?

    open class func reverseOrder() -> JavaComparator! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "reverseOrder", methodSig: "()Ljava/util/Comparator;", methodCache: &reverseOrder_MethodID_47, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? JavaComparatorForward( javaObject: __return ) : nil
    }


    /// public static java.util.Enumeration java.util.Collections.enumeration(java.util.Collection)

    private static var enumeration_MethodID_48: jmethodID?

    open class func enumeration( arg0: Collection? ) -> Enumeration! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "enumeration", methodSig: "(Ljava/util/Collection;)Ljava/util/Enumeration;", methodCache: &enumeration_MethodID_48, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? EnumerationForward( javaObject: __return ) : nil
    }

    open class func enumeration( _ _arg0: Collection? ) -> Enumeration! {
        return enumeration( arg0: _arg0 )
    }

    /// public static int java.util.Collections.frequency(java.util.Collection,java.lang.Object)

    private static var frequency_MethodID_49: jmethodID?

    open class func frequency( arg0: Collection?, arg1: java_lang.JavaObject? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "frequency", methodSig: "(Ljava/util/Collection;Ljava/lang/Object;)I", methodCache: &frequency_MethodID_49, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func frequency( _ _arg0: Collection?, _ _arg1: java_lang.JavaObject? ) -> Int {
        return frequency( arg0: _arg0, arg1: _arg1 )
    }

    /// public static boolean java.util.Collections.disjoint(java.util.Collection,java.util.Collection)

    private static var disjoint_MethodID_50: jmethodID?

    open class func disjoint( arg0: Collection?, arg1: Collection? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        __args[1] = jvalue( l: arg1?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "disjoint", methodSig: "(Ljava/util/Collection;Ljava/util/Collection;)Z", methodCache: &disjoint_MethodID_50, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open class func disjoint( _ _arg0: Collection?, _ _arg1: Collection? ) -> Bool {
        return disjoint( arg0: _arg0, arg1: _arg1 )
    }

    /// public static java.util.Set java.util.Collections.newSetFromMap(java.util.Map)

    private static var newSetFromMap_MethodID_51: jmethodID?

    open class func newSetFromMap( arg0: Map? ) -> JavaSet! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "newSetFromMap", methodSig: "(Ljava/util/Map;)Ljava/util/Set;", methodCache: &newSetFromMap_MethodID_51, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? JavaSetForward( javaObject: __return ) : nil
    }

    open class func newSetFromMap( _ _arg0: Map? ) -> JavaSet! {
        return newSetFromMap( arg0: _arg0 )
    }

    /// public static java.util.Queue java.util.Collections.asLifoQueue(java.util.Deque)

    private static var asLifoQueue_MethodID_52: jmethodID?

    open class func asLifoQueue( arg0: Deque? ) -> Queue! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Collections", classCache: &CollectionsJNIClass, methodName: "asLifoQueue", methodSig: "(Ljava/util/Deque;)Ljava/util/Queue;", methodCache: &asLifoQueue_MethodID_52, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? QueueForward( javaObject: __return ) : nil
    }

    open class func asLifoQueue( _ _arg0: Deque? ) -> Queue! {
        return asLifoQueue( arg0: _arg0 )
    }

}
