
import java_swift
import java_lang

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// class java.util.concurrent.TimeUnit ///

open class TimeUnit: java_lang.Enum {

    public convenience init?( casting object: java_swift.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        if !object.validDownCast( toJavaClass: "java.util.concurrent.TimeUnit", file, line ) {
            return nil
        }
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var TimeUnitJNIClass: jclass?

    /// public static final java.util.concurrent.TimeUnit java.util.concurrent.TimeUnit.NANOSECONDS

    private static var NANOSECONDS_FieldID: jfieldID?

    open static var NANOSECONDS: TimeUnit! {
        get {
            let __value = JNIField.GetStaticObjectField( fieldName: "NANOSECONDS", fieldType: "Ljava/util/concurrent/TimeUnit;", fieldCache: &NANOSECONDS_FieldID, className: "java/util/concurrent/TimeUnit", classCache: &TimeUnitJNIClass )
            return __value != nil ? TimeUnit( javaObject: __value ) : nil
        }
    }

    /// public static final java.util.concurrent.TimeUnit java.util.concurrent.TimeUnit.MICROSECONDS

    private static var MICROSECONDS_FieldID: jfieldID?

    open static var MICROSECONDS: TimeUnit! {
        get {
            let __value = JNIField.GetStaticObjectField( fieldName: "MICROSECONDS", fieldType: "Ljava/util/concurrent/TimeUnit;", fieldCache: &MICROSECONDS_FieldID, className: "java/util/concurrent/TimeUnit", classCache: &TimeUnitJNIClass )
            return __value != nil ? TimeUnit( javaObject: __value ) : nil
        }
    }

    /// public static final java.util.concurrent.TimeUnit java.util.concurrent.TimeUnit.MILLISECONDS

    private static var MILLISECONDS_FieldID: jfieldID?

    open static var MILLISECONDS: TimeUnit! {
        get {
            let __value = JNIField.GetStaticObjectField( fieldName: "MILLISECONDS", fieldType: "Ljava/util/concurrent/TimeUnit;", fieldCache: &MILLISECONDS_FieldID, className: "java/util/concurrent/TimeUnit", classCache: &TimeUnitJNIClass )
            return __value != nil ? TimeUnit( javaObject: __value ) : nil
        }
    }

    /// public static final java.util.concurrent.TimeUnit java.util.concurrent.TimeUnit.SECONDS

    private static var SECONDS_FieldID: jfieldID?

    open static var SECONDS: TimeUnit! {
        get {
            let __value = JNIField.GetStaticObjectField( fieldName: "SECONDS", fieldType: "Ljava/util/concurrent/TimeUnit;", fieldCache: &SECONDS_FieldID, className: "java/util/concurrent/TimeUnit", classCache: &TimeUnitJNIClass )
            return __value != nil ? TimeUnit( javaObject: __value ) : nil
        }
    }

    /// public static final java.util.concurrent.TimeUnit java.util.concurrent.TimeUnit.MINUTES

    private static var MINUTES_FieldID: jfieldID?

    open static var MINUTES: TimeUnit! {
        get {
            let __value = JNIField.GetStaticObjectField( fieldName: "MINUTES", fieldType: "Ljava/util/concurrent/TimeUnit;", fieldCache: &MINUTES_FieldID, className: "java/util/concurrent/TimeUnit", classCache: &TimeUnitJNIClass )
            return __value != nil ? TimeUnit( javaObject: __value ) : nil
        }
    }

    /// public static final java.util.concurrent.TimeUnit java.util.concurrent.TimeUnit.HOURS

    private static var HOURS_FieldID: jfieldID?

    open static var HOURS: TimeUnit! {
        get {
            let __value = JNIField.GetStaticObjectField( fieldName: "HOURS", fieldType: "Ljava/util/concurrent/TimeUnit;", fieldCache: &HOURS_FieldID, className: "java/util/concurrent/TimeUnit", classCache: &TimeUnitJNIClass )
            return __value != nil ? TimeUnit( javaObject: __value ) : nil
        }
    }

    /// public static final java.util.concurrent.TimeUnit java.util.concurrent.TimeUnit.DAYS

    private static var DAYS_FieldID: jfieldID?

    open static var DAYS: TimeUnit! {
        get {
            let __value = JNIField.GetStaticObjectField( fieldName: "DAYS", fieldType: "Ljava/util/concurrent/TimeUnit;", fieldCache: &DAYS_FieldID, className: "java/util/concurrent/TimeUnit", classCache: &TimeUnitJNIClass )
            return __value != nil ? TimeUnit( javaObject: __value ) : nil
        }
    }

    /// static final long java.util.concurrent.TimeUnit.C0

    /// static final long java.util.concurrent.TimeUnit.C1

    /// static final long java.util.concurrent.TimeUnit.C2

    /// static final long java.util.concurrent.TimeUnit.C3

    /// static final long java.util.concurrent.TimeUnit.C4

    /// static final long java.util.concurrent.TimeUnit.C5

    /// static final long java.util.concurrent.TimeUnit.C6

    /// static final long java.util.concurrent.TimeUnit.MAX

    /// private static final java.util.concurrent.TimeUnit[] java.util.concurrent.TimeUnit.$VALUES

    /// private final java.lang.String java.lang.Enum.name

    /// private final int java.lang.Enum.ordinal

    /// private java.util.concurrent.TimeUnit(java.lang.String,int)

    /// java.util.concurrent.TimeUnit(java.lang.String,int,java.util.concurrent.TimeUnit$1)

    /// public static java.util.concurrent.TimeUnit[] java.util.concurrent.TimeUnit.values()

    private static var values_MethodID_1: jmethodID?

    open class func values() -> [TimeUnit]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/concurrent/TimeUnit", classCache: &TimeUnitJNIClass, methodName: "values", methodSig: "()[Ljava/util/concurrent/TimeUnit;", methodCache: &values_MethodID_1, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: [TimeUnit](), from: __return )
    }


    /// public static java.util.concurrent.TimeUnit java.util.concurrent.TimeUnit.valueOf(java.lang.String)

    private static var valueOf_MethodID_2: jmethodID?

    open class func valueOf( name: String? ) -> TimeUnit! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: name, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/concurrent/TimeUnit", classCache: &TimeUnitJNIClass, methodName: "valueOf", methodSig: "(Ljava/lang/String;)Ljava/util/concurrent/TimeUnit;", methodCache: &valueOf_MethodID_2, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? TimeUnit( javaObject: __return ) : nil
    }

    open class func valueOf( _ _name: String? ) -> TimeUnit! {
        return valueOf( name: _name )
    }

    /// static long java.util.concurrent.TimeUnit.x(long,long,long)

    /// public void java.util.concurrent.TimeUnit.sleep(long) throws java.lang.InterruptedException

    private static var sleep_MethodID_3: jmethodID?

    open func sleep( timeout: Int64 ) throws /* java.lang.InterruptedException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: timeout, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "sleep", methodSig: "(J)V", methodCache: &TimeUnit.sleep_MethodID_3, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.InterruptedException( javaObject: throwable )
        }
    }

    open func sleep( _ _timeout: Int64 ) throws /* java.lang.InterruptedException */ {
        try sleep( timeout: _timeout )
    }

    /// public long java.util.concurrent.TimeUnit.toMillis(long)

    private static var toMillis_MethodID_4: jmethodID?

    open func toMillis( duration: Int64 ) -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: duration, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "toMillis", methodSig: "(J)J", methodCache: &TimeUnit.toMillis_MethodID_4, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int64(), from: __return )
    }

    open func toMillis( _ _duration: Int64 ) -> Int64 {
        return toMillis( duration: _duration )
    }

    /// public long java.util.concurrent.TimeUnit.toNanos(long)

    private static var toNanos_MethodID_5: jmethodID?

    open func toNanos( duration: Int64 ) -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: duration, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "toNanos", methodSig: "(J)J", methodCache: &TimeUnit.toNanos_MethodID_5, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int64(), from: __return )
    }

    open func toNanos( _ _duration: Int64 ) -> Int64 {
        return toNanos( duration: _duration )
    }

    /// public long java.util.concurrent.TimeUnit.convert(long,java.util.concurrent.TimeUnit)

    private static var convert_MethodID_6: jmethodID?

    open func convert( sourceDuration: Int64, sourceUnit: TimeUnit? ) -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: sourceDuration, locals: &__locals )
        __args[1] = JNIType.toJava( value: sourceUnit != nil ? sourceUnit! as JNIObject : nil, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "convert", methodSig: "(JLjava/util/concurrent/TimeUnit;)J", methodCache: &TimeUnit.convert_MethodID_6, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int64(), from: __return )
    }

    open func convert( _ _sourceDuration: Int64, _ _sourceUnit: TimeUnit? ) -> Int64 {
        return convert( sourceDuration: _sourceDuration, sourceUnit: _sourceUnit )
    }

    /// public long java.util.concurrent.TimeUnit.toMicros(long)

    private static var toMicros_MethodID_7: jmethodID?

    open func toMicros( duration: Int64 ) -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: duration, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "toMicros", methodSig: "(J)J", methodCache: &TimeUnit.toMicros_MethodID_7, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int64(), from: __return )
    }

    open func toMicros( _ _duration: Int64 ) -> Int64 {
        return toMicros( duration: _duration )
    }

    /// public long java.util.concurrent.TimeUnit.toSeconds(long)

    private static var toSeconds_MethodID_8: jmethodID?

    open func toSeconds( duration: Int64 ) -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: duration, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "toSeconds", methodSig: "(J)J", methodCache: &TimeUnit.toSeconds_MethodID_8, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int64(), from: __return )
    }

    open func toSeconds( _ _duration: Int64 ) -> Int64 {
        return toSeconds( duration: _duration )
    }

    /// public long java.util.concurrent.TimeUnit.toMinutes(long)

    private static var toMinutes_MethodID_9: jmethodID?

    open func toMinutes( duration: Int64 ) -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: duration, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "toMinutes", methodSig: "(J)J", methodCache: &TimeUnit.toMinutes_MethodID_9, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int64(), from: __return )
    }

    open func toMinutes( _ _duration: Int64 ) -> Int64 {
        return toMinutes( duration: _duration )
    }

    /// public long java.util.concurrent.TimeUnit.toHours(long)

    private static var toHours_MethodID_10: jmethodID?

    open func toHours( duration: Int64 ) -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: duration, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "toHours", methodSig: "(J)J", methodCache: &TimeUnit.toHours_MethodID_10, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int64(), from: __return )
    }

    open func toHours( _ _duration: Int64 ) -> Int64 {
        return toHours( duration: _duration )
    }

    /// public long java.util.concurrent.TimeUnit.toDays(long)

    private static var toDays_MethodID_11: jmethodID?

    open func toDays( duration: Int64 ) -> Int64 {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: duration, locals: &__locals )
        let __return = JNIMethod.CallLongMethod( object: javaObject, methodName: "toDays", methodSig: "(J)J", methodCache: &TimeUnit.toDays_MethodID_11, args: &__args, locals: &__locals )
        return JNIType.toSwift( type: Int64(), from: __return )
    }

    open func toDays( _ _duration: Int64 ) -> Int64 {
        return toDays( duration: _duration )
    }

    /// abstract int java.util.concurrent.TimeUnit.excessNanos(long,long)

    /// public void java.util.concurrent.TimeUnit.timedWait(java.lang.Object,long) throws java.lang.InterruptedException

    private static var timedWait_MethodID_12: jmethodID?

    open func timedWait( obj: java_swift.JavaObject?, timeout: Int64 ) throws /* java.lang.InterruptedException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: obj != nil ? obj! as JNIObject : nil, locals: &__locals )
        __args[1] = JNIType.toJava( value: timeout, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "timedWait", methodSig: "(Ljava/lang/Object;J)V", methodCache: &TimeUnit.timedWait_MethodID_12, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.InterruptedException( javaObject: throwable )
        }
    }

    open func timedWait( _ _obj: java_swift.JavaObject?, _ _timeout: Int64 ) throws /* java.lang.InterruptedException */ {
        try timedWait( obj: _obj, timeout: _timeout )
    }

    /// public void java.util.concurrent.TimeUnit.timedJoin(java.lang.Thread,long) throws java.lang.InterruptedException

    private static var timedJoin_MethodID_13: jmethodID?

    open func timedJoin( thread: java_lang.Thread?, timeout: Int64 ) throws /* java.lang.InterruptedException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.toJava( value: thread != nil ? thread! as JNIObject : nil, locals: &__locals )
        __args[1] = JNIType.toJava( value: timeout, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "timedJoin", methodSig: "(Ljava/lang/Thread;J)V", methodCache: &TimeUnit.timedJoin_MethodID_13, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.InterruptedException( javaObject: throwable )
        }
    }

    open func timedJoin( _ _thread: java_lang.Thread?, _ _timeout: Int64 ) throws /* java.lang.InterruptedException */ {
        try timedJoin( thread: _thread, timeout: _timeout )
    }

}

