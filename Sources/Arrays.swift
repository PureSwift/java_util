
import java_swift
import java_lang

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// JAVA_HOME: /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home ///
/// Tue Dec 20 11:30:08 GMT 2016 ///

/// class java.util.Arrays ///

open class Arrays: java_lang.JavaObject {

    public convenience init?( casting object: java_lang.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        if !object.validDownCast( toJavaClass: "java.util.Arrays", file, line ) {
            return nil
        }
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var ArraysJNIClass: jclass?

    /// private static final int java.util.Arrays.INSERTIONSORT_THRESHOLD

    /// private java.util.Arrays()

    /// public static boolean java.util.Arrays.equals(int[],int[])

    private static var equals_MethodID_1: jmethodID?

    open class func equals( arg0: [Int32]?, arg1: [Int32]? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "equals", methodSig: "([I[I)Z", methodCache: &equals_MethodID_1, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open class func equals( _ _arg0: [Int32]?, _ _arg1: [Int32]? ) -> Bool {
        return equals( arg0: _arg0, arg1: _arg1 )
    }

    /// public static boolean java.util.Arrays.equals(byte[],byte[])

    private static var equals_MethodID_2: jmethodID?

    open class func equals( arg0: [Int8]?, arg1: [Int8]? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "equals", methodSig: "([B[B)Z", methodCache: &equals_MethodID_2, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open class func equals( _ _arg0: [Int8]?, _ _arg1: [Int8]? ) -> Bool {
        return equals( arg0: _arg0, arg1: _arg1 )
    }

    /// public static boolean java.util.Arrays.equals(boolean[],boolean[])

    private static var equals_MethodID_3: jmethodID?

    open class func equals( arg0: [Bool]?, arg1: [Bool]? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "equals", methodSig: "([Z[Z)Z", methodCache: &equals_MethodID_3, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open class func equals( _ _arg0: [Bool]?, _ _arg1: [Bool]? ) -> Bool {
        return equals( arg0: _arg0, arg1: _arg1 )
    }

    /// public static boolean java.util.Arrays.equals(double[],double[])

    private static var equals_MethodID_4: jmethodID?

    open class func equals( arg0: [Double]?, arg1: [Double]? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "equals", methodSig: "([D[D)Z", methodCache: &equals_MethodID_4, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open class func equals( _ _arg0: [Double]?, _ _arg1: [Double]? ) -> Bool {
        return equals( arg0: _arg0, arg1: _arg1 )
    }

    /// public static boolean java.util.Arrays.equals(float[],float[])

    private static var equals_MethodID_5: jmethodID?

    open class func equals( arg0: [Float]?, arg1: [Float]? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "equals", methodSig: "([F[F)Z", methodCache: &equals_MethodID_5, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open class func equals( _ _arg0: [Float]?, _ _arg1: [Float]? ) -> Bool {
        return equals( arg0: _arg0, arg1: _arg1 )
    }

    /// public static boolean java.util.Arrays.equals(java.lang.Object[],java.lang.Object[])

    private static var equals_MethodID_6: jmethodID?

    open class func equals( arg0: [JavaObject]?, arg1: [JavaObject]? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "equals", methodSig: "([Ljava/lang/Object;[Ljava/lang/Object;)Z", methodCache: &equals_MethodID_6, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open class func equals( _ _arg0: [JavaObject]?, _ _arg1: [JavaObject]? ) -> Bool {
        return equals( arg0: _arg0, arg1: _arg1 )
    }

    /// public static boolean java.util.Arrays.equals(long[],long[])

    private static var equals_MethodID_7: jmethodID?

    open class func equals( arg0: [Int64]?, arg1: [Int64]? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "equals", methodSig: "([J[J)Z", methodCache: &equals_MethodID_7, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open class func equals( _ _arg0: [Int64]?, _ _arg1: [Int64]? ) -> Bool {
        return equals( arg0: _arg0, arg1: _arg1 )
    }

    /// public static boolean java.util.Arrays.equals(short[],short[])

    private static var equals_MethodID_8: jmethodID?

    open class func equals( arg0: [Int16]?, arg1: [Int16]? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "equals", methodSig: "([S[S)Z", methodCache: &equals_MethodID_8, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open class func equals( _ _arg0: [Int16]?, _ _arg1: [Int16]? ) -> Bool {
        return equals( arg0: _arg0, arg1: _arg1 )
    }

    /// public static boolean java.util.Arrays.equals(char[],char[])

    private static var equals_MethodID_9: jmethodID?

    open class func equals( arg0: [UInt16]?, arg1: [UInt16]? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "equals", methodSig: "([C[C)Z", methodCache: &equals_MethodID_9, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open class func equals( _ _arg0: [UInt16]?, _ _arg1: [UInt16]? ) -> Bool {
        return equals( arg0: _arg0, arg1: _arg1 )
    }

    /// public static java.lang.String java.util.Arrays.toString(boolean[])

    private static var toString_MethodID_10: jmethodID?

    open class func toString( arg0: [Bool]? ) -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "toString", methodSig: "([Z)Ljava/lang/String;", methodCache: &toString_MethodID_10, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }

    open class func toString( _ _arg0: [Bool]? ) -> String! {
        return toString( arg0: _arg0 )
    }

    /// public static java.lang.String java.util.Arrays.toString(char[])

    private static var toString_MethodID_11: jmethodID?

    open class func toString( arg0: [UInt16]? ) -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "toString", methodSig: "([C)Ljava/lang/String;", methodCache: &toString_MethodID_11, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }

    open class func toString( _ _arg0: [UInt16]? ) -> String! {
        return toString( arg0: _arg0 )
    }

    /// public static java.lang.String java.util.Arrays.toString(short[])

    private static var toString_MethodID_12: jmethodID?

    open class func toString( arg0: [Int16]? ) -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "toString", methodSig: "([S)Ljava/lang/String;", methodCache: &toString_MethodID_12, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }

    open class func toString( _ _arg0: [Int16]? ) -> String! {
        return toString( arg0: _arg0 )
    }

    /// public static java.lang.String java.util.Arrays.toString(int[])

    private static var toString_MethodID_13: jmethodID?

    open class func toString( arg0: [Int32]? ) -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "toString", methodSig: "([I)Ljava/lang/String;", methodCache: &toString_MethodID_13, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }

    open class func toString( _ _arg0: [Int32]? ) -> String! {
        return toString( arg0: _arg0 )
    }

    /// public static java.lang.String java.util.Arrays.toString(long[])

    private static var toString_MethodID_14: jmethodID?

    open class func toString( arg0: [Int64]? ) -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "toString", methodSig: "([J)Ljava/lang/String;", methodCache: &toString_MethodID_14, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }

    open class func toString( _ _arg0: [Int64]? ) -> String! {
        return toString( arg0: _arg0 )
    }

    /// public static java.lang.String java.util.Arrays.toString(float[])

    private static var toString_MethodID_15: jmethodID?

    open class func toString( arg0: [Float]? ) -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "toString", methodSig: "([F)Ljava/lang/String;", methodCache: &toString_MethodID_15, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }

    open class func toString( _ _arg0: [Float]? ) -> String! {
        return toString( arg0: _arg0 )
    }

    /// public static java.lang.String java.util.Arrays.toString(double[])

    private static var toString_MethodID_16: jmethodID?

    open class func toString( arg0: [Double]? ) -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "toString", methodSig: "([D)Ljava/lang/String;", methodCache: &toString_MethodID_16, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }

    open class func toString( _ _arg0: [Double]? ) -> String! {
        return toString( arg0: _arg0 )
    }

    /// public static java.lang.String java.util.Arrays.toString(java.lang.Object[])

    private static var toString_MethodID_17: jmethodID?

    open class func toString( arg0: [JavaObject]? ) -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "toString", methodSig: "([Ljava/lang/Object;)Ljava/lang/String;", methodCache: &toString_MethodID_17, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }

    open class func toString( _ _arg0: [JavaObject]? ) -> String! {
        return toString( arg0: _arg0 )
    }

    /// public static java.lang.String java.util.Arrays.toString(byte[])

    private static var toString_MethodID_18: jmethodID?

    open class func toString( arg0: [Int8]? ) -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "toString", methodSig: "([B)Ljava/lang/String;", methodCache: &toString_MethodID_18, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }

    open class func toString( _ _arg0: [Int8]? ) -> String! {
        return toString( arg0: _arg0 )
    }

    /// public static int java.util.Arrays.hashCode(boolean[])

    private static var hashCode_MethodID_19: jmethodID?

    open class func hashCode( arg0: [Bool]? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "hashCode", methodSig: "([Z)I", methodCache: &hashCode_MethodID_19, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func hashCode( _ _arg0: [Bool]? ) -> Int {
        return hashCode( arg0: _arg0 )
    }

    /// public static int java.util.Arrays.hashCode(long[])

    private static var hashCode_MethodID_20: jmethodID?

    open class func hashCode( arg0: [Int64]? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "hashCode", methodSig: "([J)I", methodCache: &hashCode_MethodID_20, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func hashCode( _ _arg0: [Int64]? ) -> Int {
        return hashCode( arg0: _arg0 )
    }

    /// public static int java.util.Arrays.hashCode(int[])

    private static var hashCode_MethodID_21: jmethodID?

    open class func hashCode( arg0: [Int32]? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "hashCode", methodSig: "([I)I", methodCache: &hashCode_MethodID_21, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func hashCode( _ _arg0: [Int32]? ) -> Int {
        return hashCode( arg0: _arg0 )
    }

    /// public static int java.util.Arrays.hashCode(short[])

    private static var hashCode_MethodID_22: jmethodID?

    open class func hashCode( arg0: [Int16]? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "hashCode", methodSig: "([S)I", methodCache: &hashCode_MethodID_22, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func hashCode( _ _arg0: [Int16]? ) -> Int {
        return hashCode( arg0: _arg0 )
    }

    /// public static int java.util.Arrays.hashCode(char[])

    private static var hashCode_MethodID_23: jmethodID?

    open class func hashCode( arg0: [UInt16]? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "hashCode", methodSig: "([C)I", methodCache: &hashCode_MethodID_23, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func hashCode( _ _arg0: [UInt16]? ) -> Int {
        return hashCode( arg0: _arg0 )
    }

    /// public static int java.util.Arrays.hashCode(java.lang.Object[])

    private static var hashCode_MethodID_24: jmethodID?

    open class func hashCode( arg0: [JavaObject]? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "hashCode", methodSig: "([Ljava/lang/Object;)I", methodCache: &hashCode_MethodID_24, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func hashCode( _ _arg0: [JavaObject]? ) -> Int {
        return hashCode( arg0: _arg0 )
    }

    /// public static int java.util.Arrays.hashCode(double[])

    private static var hashCode_MethodID_25: jmethodID?

    open class func hashCode( arg0: [Double]? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "hashCode", methodSig: "([D)I", methodCache: &hashCode_MethodID_25, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func hashCode( _ _arg0: [Double]? ) -> Int {
        return hashCode( arg0: _arg0 )
    }

    /// public static int java.util.Arrays.hashCode(float[])

    private static var hashCode_MethodID_26: jmethodID?

    open class func hashCode( arg0: [Float]? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "hashCode", methodSig: "([F)I", methodCache: &hashCode_MethodID_26, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func hashCode( _ _arg0: [Float]? ) -> Int {
        return hashCode( arg0: _arg0 )
    }

    /// public static int java.util.Arrays.hashCode(byte[])

    private static var hashCode_MethodID_27: jmethodID?

    open class func hashCode( arg0: [Int8]? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "hashCode", methodSig: "([B)I", methodCache: &hashCode_MethodID_27, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func hashCode( _ _arg0: [Int8]? ) -> Int {
        return hashCode( arg0: _arg0 )
    }

    /// public static int[] java.util.Arrays.copyOf(int[],int)

    private static var copyOf_MethodID_28: jmethodID?

    open class func copyOf( arg0: [Int32]?, arg1: Int ) -> [Int32]! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([II)[I", methodCache: &copyOf_MethodID_28, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Int32](), from: __return )
    }

    open class func copyOf( _ _arg0: [Int32]?, _ _arg1: Int ) -> [Int32]! {
        return copyOf( arg0: _arg0, arg1: _arg1 )
    }

    /// public static boolean[] java.util.Arrays.copyOf(boolean[],int)

    private static var copyOf_MethodID_29: jmethodID?

    open class func copyOf( arg0: [Bool]?, arg1: Int ) -> [Bool]! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([ZI)[Z", methodCache: &copyOf_MethodID_29, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Bool](), from: __return )
    }

    open class func copyOf( _ _arg0: [Bool]?, _ _arg1: Int ) -> [Bool]! {
        return copyOf( arg0: _arg0, arg1: _arg1 )
    }

    /// public static double[] java.util.Arrays.copyOf(double[],int)

    private static var copyOf_MethodID_30: jmethodID?

    open class func copyOf( arg0: [Double]?, arg1: Int ) -> [Double]! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([DI)[D", methodCache: &copyOf_MethodID_30, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Double](), from: __return )
    }

    open class func copyOf( _ _arg0: [Double]?, _ _arg1: Int ) -> [Double]! {
        return copyOf( arg0: _arg0, arg1: _arg1 )
    }

    /// public static float[] java.util.Arrays.copyOf(float[],int)

    private static var copyOf_MethodID_31: jmethodID?

    open class func copyOf( arg0: [Float]?, arg1: Int ) -> [Float]! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([FI)[F", methodCache: &copyOf_MethodID_31, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Float](), from: __return )
    }

    open class func copyOf( _ _arg0: [Float]?, _ _arg1: Int ) -> [Float]! {
        return copyOf( arg0: _arg0, arg1: _arg1 )
    }

    /// public static char[] java.util.Arrays.copyOf(char[],int)

    private static var copyOf_MethodID_32: jmethodID?

    open class func copyOf( arg0: [UInt16]?, arg1: Int ) -> [UInt16]! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([CI)[C", methodCache: &copyOf_MethodID_32, args: &__args, locals: &__locals )
        return JNIType.decode( type: [UInt16](), from: __return )
    }

    open class func copyOf( _ _arg0: [UInt16]?, _ _arg1: Int ) -> [UInt16]! {
        return copyOf( arg0: _arg0, arg1: _arg1 )
    }

    /// public static long[] java.util.Arrays.copyOf(long[],int)

    private static var copyOf_MethodID_33: jmethodID?

    open class func copyOf( arg0: [Int64]?, arg1: Int ) -> [Int64]! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([JI)[J", methodCache: &copyOf_MethodID_33, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Int64](), from: __return )
    }

    open class func copyOf( _ _arg0: [Int64]?, _ _arg1: Int ) -> [Int64]! {
        return copyOf( arg0: _arg0, arg1: _arg1 )
    }

    /// public static short[] java.util.Arrays.copyOf(short[],int)

    private static var copyOf_MethodID_34: jmethodID?

    open class func copyOf( arg0: [Int16]?, arg1: Int ) -> [Int16]! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([SI)[S", methodCache: &copyOf_MethodID_34, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Int16](), from: __return )
    }

    open class func copyOf( _ _arg0: [Int16]?, _ _arg1: Int ) -> [Int16]! {
        return copyOf( arg0: _arg0, arg1: _arg1 )
    }

    /// public static byte[] java.util.Arrays.copyOf(byte[],int)

    private static var copyOf_MethodID_35: jmethodID?

    open class func copyOf( arg0: [Int8]?, arg1: Int ) -> [Int8]! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([BI)[B", methodCache: &copyOf_MethodID_35, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Int8](), from: __return )
    }

    open class func copyOf( _ _arg0: [Int8]?, _ _arg1: Int ) -> [Int8]! {
        return copyOf( arg0: _arg0, arg1: _arg1 )
    }

    /// public static java.lang.Object[] java.util.Arrays.copyOf(java.lang.Object[],int,java.lang.Class)

    private static var copyOf_MethodID_36: jmethodID?

    open class func copyOf( arg0: [JavaObject]?, arg1: Int, arg2: java_lang.Class? ) -> [JavaObject]! {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([Ljava/lang/Object;ILjava/lang/Class;)[Ljava/lang/Object;", methodCache: &copyOf_MethodID_36, args: &__args, locals: &__locals )
        return JNIType.decode( type: [JavaObject](), from: __return )
    }

    open class func copyOf( _ _arg0: [JavaObject]?, _ _arg1: Int, _ _arg2: java_lang.Class? ) -> [JavaObject]! {
        return copyOf( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static java.lang.Object[] java.util.Arrays.copyOf(java.lang.Object[],int)

    private static var copyOf_MethodID_37: jmethodID?

    open class func copyOf( arg0: [JavaObject]?, arg1: Int ) -> [JavaObject]! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOf", methodSig: "([Ljava/lang/Object;I)[Ljava/lang/Object;", methodCache: &copyOf_MethodID_37, args: &__args, locals: &__locals )
        return JNIType.decode( type: [JavaObject](), from: __return )
    }

    open class func copyOf( _ _arg0: [JavaObject]?, _ _arg1: Int ) -> [JavaObject]! {
        return copyOf( arg0: _arg0, arg1: _arg1 )
    }

    /// public static java.lang.Object[] java.util.Arrays.copyOfRange(java.lang.Object[],int,int,java.lang.Class)

    private static var copyOfRange_MethodID_38: jmethodID?

    open class func copyOfRange( arg0: [JavaObject]?, arg1: Int, arg2: Int, arg3: java_lang.Class? ) -> [JavaObject]! {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([Ljava/lang/Object;IILjava/lang/Class;)[Ljava/lang/Object;", methodCache: &copyOfRange_MethodID_38, args: &__args, locals: &__locals )
        return JNIType.decode( type: [JavaObject](), from: __return )
    }

    open class func copyOfRange( _ _arg0: [JavaObject]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: java_lang.Class? ) -> [JavaObject]! {
        return copyOfRange( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static float[] java.util.Arrays.copyOfRange(float[],int,int)

    private static var copyOfRange_MethodID_39: jmethodID?

    open class func copyOfRange( arg0: [Float]?, arg1: Int, arg2: Int ) -> [Float]! {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([FII)[F", methodCache: &copyOfRange_MethodID_39, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Float](), from: __return )
    }

    open class func copyOfRange( _ _arg0: [Float]?, _ _arg1: Int, _ _arg2: Int ) -> [Float]! {
        return copyOfRange( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static double[] java.util.Arrays.copyOfRange(double[],int,int)

    private static var copyOfRange_MethodID_40: jmethodID?

    open class func copyOfRange( arg0: [Double]?, arg1: Int, arg2: Int ) -> [Double]! {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([DII)[D", methodCache: &copyOfRange_MethodID_40, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Double](), from: __return )
    }

    open class func copyOfRange( _ _arg0: [Double]?, _ _arg1: Int, _ _arg2: Int ) -> [Double]! {
        return copyOfRange( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static java.lang.Object[] java.util.Arrays.copyOfRange(java.lang.Object[],int,int)

    private static var copyOfRange_MethodID_41: jmethodID?

    open class func copyOfRange( arg0: [JavaObject]?, arg1: Int, arg2: Int ) -> [JavaObject]! {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([Ljava/lang/Object;II)[Ljava/lang/Object;", methodCache: &copyOfRange_MethodID_41, args: &__args, locals: &__locals )
        return JNIType.decode( type: [JavaObject](), from: __return )
    }

    open class func copyOfRange( _ _arg0: [JavaObject]?, _ _arg1: Int, _ _arg2: Int ) -> [JavaObject]! {
        return copyOfRange( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static short[] java.util.Arrays.copyOfRange(short[],int,int)

    private static var copyOfRange_MethodID_42: jmethodID?

    open class func copyOfRange( arg0: [Int16]?, arg1: Int, arg2: Int ) -> [Int16]! {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([SII)[S", methodCache: &copyOfRange_MethodID_42, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Int16](), from: __return )
    }

    open class func copyOfRange( _ _arg0: [Int16]?, _ _arg1: Int, _ _arg2: Int ) -> [Int16]! {
        return copyOfRange( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static boolean[] java.util.Arrays.copyOfRange(boolean[],int,int)

    private static var copyOfRange_MethodID_43: jmethodID?

    open class func copyOfRange( arg0: [Bool]?, arg1: Int, arg2: Int ) -> [Bool]! {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([ZII)[Z", methodCache: &copyOfRange_MethodID_43, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Bool](), from: __return )
    }

    open class func copyOfRange( _ _arg0: [Bool]?, _ _arg1: Int, _ _arg2: Int ) -> [Bool]! {
        return copyOfRange( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static byte[] java.util.Arrays.copyOfRange(byte[],int,int)

    private static var copyOfRange_MethodID_44: jmethodID?

    open class func copyOfRange( arg0: [Int8]?, arg1: Int, arg2: Int ) -> [Int8]! {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([BII)[B", methodCache: &copyOfRange_MethodID_44, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Int8](), from: __return )
    }

    open class func copyOfRange( _ _arg0: [Int8]?, _ _arg1: Int, _ _arg2: Int ) -> [Int8]! {
        return copyOfRange( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static long[] java.util.Arrays.copyOfRange(long[],int,int)

    private static var copyOfRange_MethodID_45: jmethodID?

    open class func copyOfRange( arg0: [Int64]?, arg1: Int, arg2: Int ) -> [Int64]! {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([JII)[J", methodCache: &copyOfRange_MethodID_45, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Int64](), from: __return )
    }

    open class func copyOfRange( _ _arg0: [Int64]?, _ _arg1: Int, _ _arg2: Int ) -> [Int64]! {
        return copyOfRange( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static char[] java.util.Arrays.copyOfRange(char[],int,int)

    private static var copyOfRange_MethodID_46: jmethodID?

    open class func copyOfRange( arg0: [UInt16]?, arg1: Int, arg2: Int ) -> [UInt16]! {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([CII)[C", methodCache: &copyOfRange_MethodID_46, args: &__args, locals: &__locals )
        return JNIType.decode( type: [UInt16](), from: __return )
    }

    open class func copyOfRange( _ _arg0: [UInt16]?, _ _arg1: Int, _ _arg2: Int ) -> [UInt16]! {
        return copyOfRange( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static int[] java.util.Arrays.copyOfRange(int[],int,int)

    private static var copyOfRange_MethodID_47: jmethodID?

    open class func copyOfRange( arg0: [Int32]?, arg1: Int, arg2: Int ) -> [Int32]! {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "copyOfRange", methodSig: "([III)[I", methodCache: &copyOfRange_MethodID_47, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Int32](), from: __return )
    }

    open class func copyOfRange( _ _arg0: [Int32]?, _ _arg1: Int, _ _arg2: Int ) -> [Int32]! {
        return copyOfRange( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static void java.util.Arrays.fill(short[],short)

    private static var fill_MethodID_48: jmethodID?

    open class func fill( arg0: [Int16]?, arg1: Int16 ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([SS)V", methodCache: &fill_MethodID_48, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: [Int16]?, _ _arg1: Int16 ) {
        fill( arg0: _arg0, arg1: _arg1 )
    }

    /// public static void java.util.Arrays.fill(char[],char)

    private static var fill_MethodID_49: jmethodID?

    open class func fill( arg0: [UInt16]?, arg1: UInt16 ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([CC)V", methodCache: &fill_MethodID_49, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: [UInt16]?, _ _arg1: UInt16 ) {
        fill( arg0: _arg0, arg1: _arg1 )
    }

    /// public static void java.util.Arrays.fill(float[],float)

    private static var fill_MethodID_50: jmethodID?

    open class func fill( arg0: [Float]?, arg1: Float ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([FF)V", methodCache: &fill_MethodID_50, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: [Float]?, _ _arg1: Float ) {
        fill( arg0: _arg0, arg1: _arg1 )
    }

    /// public static void java.util.Arrays.fill(short[],int,int,short)

    private static var fill_MethodID_51: jmethodID?

    open class func fill( arg0: [Int16]?, arg1: Int, arg2: Int, arg3: Int16 ) {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([SIIS)V", methodCache: &fill_MethodID_51, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: [Int16]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: Int16 ) {
        fill( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static void java.util.Arrays.fill(double[],int,int,double)

    private static var fill_MethodID_52: jmethodID?

    open class func fill( arg0: [Double]?, arg1: Int, arg2: Int, arg3: Double ) {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([DIID)V", methodCache: &fill_MethodID_52, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: [Double]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: Double ) {
        fill( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static void java.util.Arrays.fill(byte[],byte)

    private static var fill_MethodID_53: jmethodID?

    open class func fill( arg0: [Int8]?, arg1: Int8 ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([BB)V", methodCache: &fill_MethodID_53, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: [Int8]?, _ _arg1: Int8 ) {
        fill( arg0: _arg0, arg1: _arg1 )
    }

    /// public static void java.util.Arrays.fill(int[],int,int,int)

    private static var fill_MethodID_54: jmethodID?

    open class func fill( arg0: [Int32]?, arg1: Int, arg2: Int, arg3: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([IIII)V", methodCache: &fill_MethodID_54, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: [Int32]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: Int ) {
        fill( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static void java.util.Arrays.fill(int[],int)

    private static var fill_MethodID_55: jmethodID?

    open class func fill( arg0: [Int32]?, arg1: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([II)V", methodCache: &fill_MethodID_55, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: [Int32]?, _ _arg1: Int ) {
        fill( arg0: _arg0, arg1: _arg1 )
    }

    /// public static void java.util.Arrays.fill(long[],int,int,long)

    private static var fill_MethodID_56: jmethodID?

    open class func fill( arg0: [Int64]?, arg1: Int, arg2: Int, arg3: Int64 ) {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([JIIJ)V", methodCache: &fill_MethodID_56, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: [Int64]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: Int64 ) {
        fill( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static void java.util.Arrays.fill(long[],long)

    private static var fill_MethodID_57: jmethodID?

    open class func fill( arg0: [Int64]?, arg1: Int64 ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([JJ)V", methodCache: &fill_MethodID_57, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: [Int64]?, _ _arg1: Int64 ) {
        fill( arg0: _arg0, arg1: _arg1 )
    }

    /// public static void java.util.Arrays.fill(java.lang.Object[],int,int,java.lang.Object)

    private static var fill_MethodID_58: jmethodID?

    open class func fill( arg0: [JavaObject]?, arg1: Int, arg2: Int, arg3: java_lang.JavaObject? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([Ljava/lang/Object;IILjava/lang/Object;)V", methodCache: &fill_MethodID_58, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: [JavaObject]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: java_lang.JavaObject? ) {
        fill( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static void java.util.Arrays.fill(java.lang.Object[],java.lang.Object)

    private static var fill_MethodID_59: jmethodID?

    open class func fill( arg0: [JavaObject]?, arg1: java_lang.JavaObject? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([Ljava/lang/Object;Ljava/lang/Object;)V", methodCache: &fill_MethodID_59, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: [JavaObject]?, _ _arg1: java_lang.JavaObject? ) {
        fill( arg0: _arg0, arg1: _arg1 )
    }

    /// public static void java.util.Arrays.fill(float[],int,int,float)

    private static var fill_MethodID_60: jmethodID?

    open class func fill( arg0: [Float]?, arg1: Int, arg2: Int, arg3: Float ) {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([FIIF)V", methodCache: &fill_MethodID_60, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: [Float]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: Float ) {
        fill( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static void java.util.Arrays.fill(char[],int,int,char)

    private static var fill_MethodID_61: jmethodID?

    open class func fill( arg0: [UInt16]?, arg1: Int, arg2: Int, arg3: UInt16 ) {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([CIIC)V", methodCache: &fill_MethodID_61, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: [UInt16]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: UInt16 ) {
        fill( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static void java.util.Arrays.fill(double[],double)

    private static var fill_MethodID_62: jmethodID?

    open class func fill( arg0: [Double]?, arg1: Double ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([DD)V", methodCache: &fill_MethodID_62, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: [Double]?, _ _arg1: Double ) {
        fill( arg0: _arg0, arg1: _arg1 )
    }

    /// public static void java.util.Arrays.fill(boolean[],int,int,boolean)

    private static var fill_MethodID_63: jmethodID?

    open class func fill( arg0: [Bool]?, arg1: Int, arg2: Int, arg3: Bool ) {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([ZIIZ)V", methodCache: &fill_MethodID_63, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: [Bool]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: Bool ) {
        fill( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static void java.util.Arrays.fill(boolean[],boolean)

    private static var fill_MethodID_64: jmethodID?

    open class func fill( arg0: [Bool]?, arg1: Bool ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([ZZ)V", methodCache: &fill_MethodID_64, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: [Bool]?, _ _arg1: Bool ) {
        fill( arg0: _arg0, arg1: _arg1 )
    }

    /// public static void java.util.Arrays.fill(byte[],int,int,byte)

    private static var fill_MethodID_65: jmethodID?

    open class func fill( arg0: [Int8]?, arg1: Int, arg2: Int, arg3: Int8 ) {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "fill", methodSig: "([BIIB)V", methodCache: &fill_MethodID_65, args: &__args, locals: &__locals )
    }

    open class func fill( _ _arg0: [Int8]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: Int8 ) {
        fill( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static void java.util.Arrays.sort(byte[])

    private static var sort_MethodID_66: jmethodID?

    open class func sort( arg0: [Int8]? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([B)V", methodCache: &sort_MethodID_66, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: [Int8]? ) {
        sort( arg0: _arg0 )
    }

    /// public static void java.util.Arrays.sort(java.lang.Object[],java.util.Comparator)

    private static var sort_MethodID_67: jmethodID?

    open class func sort( arg0: [JavaObject]?, arg1: JavaComparator? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = jvalue( l: arg1?.localJavaObject( &__locals ) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([Ljava/lang/Object;Ljava/util/Comparator;)V", methodCache: &sort_MethodID_67, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: [JavaObject]?, _ _arg1: JavaComparator? ) {
        sort( arg0: _arg0, arg1: _arg1 )
    }

    /// public static void java.util.Arrays.sort(double[])

    private static var sort_MethodID_68: jmethodID?

    open class func sort( arg0: [Double]? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([D)V", methodCache: &sort_MethodID_68, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: [Double]? ) {
        sort( arg0: _arg0 )
    }

    /// public static void java.util.Arrays.sort(double[],int,int)

    private static var sort_MethodID_69: jmethodID?

    open class func sort( arg0: [Double]?, arg1: Int, arg2: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([DII)V", methodCache: &sort_MethodID_69, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: [Double]?, _ _arg1: Int, _ _arg2: Int ) {
        sort( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static void java.util.Arrays.sort(java.lang.Object[],int,int)

    private static var sort_MethodID_70: jmethodID?

    open class func sort( arg0: [JavaObject]?, arg1: Int, arg2: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([Ljava/lang/Object;II)V", methodCache: &sort_MethodID_70, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: [JavaObject]?, _ _arg1: Int, _ _arg2: Int ) {
        sort( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static void java.util.Arrays.sort(float[])

    private static var sort_MethodID_71: jmethodID?

    open class func sort( arg0: [Float]? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([F)V", methodCache: &sort_MethodID_71, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: [Float]? ) {
        sort( arg0: _arg0 )
    }

    /// public static void java.util.Arrays.sort(long[],int,int)

    private static var sort_MethodID_72: jmethodID?

    open class func sort( arg0: [Int64]?, arg1: Int, arg2: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([JII)V", methodCache: &sort_MethodID_72, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: [Int64]?, _ _arg1: Int, _ _arg2: Int ) {
        sort( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static void java.util.Arrays.sort(float[],int,int)

    private static var sort_MethodID_73: jmethodID?

    open class func sort( arg0: [Float]?, arg1: Int, arg2: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([FII)V", methodCache: &sort_MethodID_73, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: [Float]?, _ _arg1: Int, _ _arg2: Int ) {
        sort( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static void java.util.Arrays.sort(int[])

    private static var sort_MethodID_74: jmethodID?

    open class func sort( arg0: [Int32]? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([I)V", methodCache: &sort_MethodID_74, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: [Int32]? ) {
        sort( arg0: _arg0 )
    }

    /// public static void java.util.Arrays.sort(int[],int,int)

    private static var sort_MethodID_75: jmethodID?

    open class func sort( arg0: [Int32]?, arg1: Int, arg2: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([III)V", methodCache: &sort_MethodID_75, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: [Int32]?, _ _arg1: Int, _ _arg2: Int ) {
        sort( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static void java.util.Arrays.sort(java.lang.Object[])

    private static var sort_MethodID_76: jmethodID?

    open class func sort( arg0: [JavaObject]? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([Ljava/lang/Object;)V", methodCache: &sort_MethodID_76, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: [JavaObject]? ) {
        sort( arg0: _arg0 )
    }

    /// public static void java.util.Arrays.sort(short[])

    private static var sort_MethodID_77: jmethodID?

    open class func sort( arg0: [Int16]? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([S)V", methodCache: &sort_MethodID_77, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: [Int16]? ) {
        sort( arg0: _arg0 )
    }

    /// public static void java.util.Arrays.sort(short[],int,int)

    private static var sort_MethodID_78: jmethodID?

    open class func sort( arg0: [Int16]?, arg1: Int, arg2: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([SII)V", methodCache: &sort_MethodID_78, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: [Int16]?, _ _arg1: Int, _ _arg2: Int ) {
        sort( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static void java.util.Arrays.sort(long[])

    private static var sort_MethodID_79: jmethodID?

    open class func sort( arg0: [Int64]? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([J)V", methodCache: &sort_MethodID_79, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: [Int64]? ) {
        sort( arg0: _arg0 )
    }

    /// public static void java.util.Arrays.sort(char[])

    private static var sort_MethodID_80: jmethodID?

    open class func sort( arg0: [UInt16]? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([C)V", methodCache: &sort_MethodID_80, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: [UInt16]? ) {
        sort( arg0: _arg0 )
    }

    /// public static void java.util.Arrays.sort(char[],int,int)

    private static var sort_MethodID_81: jmethodID?

    open class func sort( arg0: [UInt16]?, arg1: Int, arg2: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([CII)V", methodCache: &sort_MethodID_81, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: [UInt16]?, _ _arg1: Int, _ _arg2: Int ) {
        sort( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static void java.util.Arrays.sort(java.lang.Object[],int,int,java.util.Comparator)

    private static var sort_MethodID_82: jmethodID?

    open class func sort( arg0: [JavaObject]?, arg1: Int, arg2: Int, arg3: JavaComparator? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = jvalue( l: arg3?.localJavaObject( &__locals ) )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([Ljava/lang/Object;IILjava/util/Comparator;)V", methodCache: &sort_MethodID_82, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: [JavaObject]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: JavaComparator? ) {
        sort( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static void java.util.Arrays.sort(byte[],int,int)

    private static var sort_MethodID_83: jmethodID?

    open class func sort( arg0: [Int8]?, arg1: Int, arg2: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallStaticVoidMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "sort", methodSig: "([BII)V", methodCache: &sort_MethodID_83, args: &__args, locals: &__locals )
    }

    open class func sort( _ _arg0: [Int8]?, _ _arg1: Int, _ _arg2: Int ) {
        sort( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static int java.util.Arrays.binarySearch(java.lang.Object[],int,int,java.lang.Object)

    private static var binarySearch_MethodID_84: jmethodID?

    open class func binarySearch( arg0: [JavaObject]?, arg1: Int, arg2: Int, arg3: java_lang.JavaObject? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([Ljava/lang/Object;IILjava/lang/Object;)I", methodCache: &binarySearch_MethodID_84, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: [JavaObject]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: java_lang.JavaObject? ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static int java.util.Arrays.binarySearch(long[],long)

    private static var binarySearch_MethodID_85: jmethodID?

    open class func binarySearch( arg0: [Int64]?, arg1: Int64 ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([JJ)I", methodCache: &binarySearch_MethodID_85, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: [Int64]?, _ _arg1: Int64 ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1 )
    }

    /// public static int java.util.Arrays.binarySearch(long[],int,int,long)

    private static var binarySearch_MethodID_86: jmethodID?

    open class func binarySearch( arg0: [Int64]?, arg1: Int, arg2: Int, arg3: Int64 ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([JIIJ)I", methodCache: &binarySearch_MethodID_86, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: [Int64]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: Int64 ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static int java.util.Arrays.binarySearch(int[],int)

    private static var binarySearch_MethodID_87: jmethodID?

    open class func binarySearch( arg0: [Int32]?, arg1: Int ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([II)I", methodCache: &binarySearch_MethodID_87, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: [Int32]?, _ _arg1: Int ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1 )
    }

    /// public static int java.util.Arrays.binarySearch(int[],int,int,int)

    private static var binarySearch_MethodID_88: jmethodID?

    open class func binarySearch( arg0: [Int32]?, arg1: Int, arg2: Int, arg3: Int ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([IIII)I", methodCache: &binarySearch_MethodID_88, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: [Int32]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: Int ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static int java.util.Arrays.binarySearch(short[],short)

    private static var binarySearch_MethodID_89: jmethodID?

    open class func binarySearch( arg0: [Int16]?, arg1: Int16 ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([SS)I", methodCache: &binarySearch_MethodID_89, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: [Int16]?, _ _arg1: Int16 ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1 )
    }

    /// public static int java.util.Arrays.binarySearch(short[],int,int,short)

    private static var binarySearch_MethodID_90: jmethodID?

    open class func binarySearch( arg0: [Int16]?, arg1: Int, arg2: Int, arg3: Int16 ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([SIIS)I", methodCache: &binarySearch_MethodID_90, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: [Int16]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: Int16 ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static int java.util.Arrays.binarySearch(char[],char)

    private static var binarySearch_MethodID_91: jmethodID?

    open class func binarySearch( arg0: [UInt16]?, arg1: UInt16 ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([CC)I", methodCache: &binarySearch_MethodID_91, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: [UInt16]?, _ _arg1: UInt16 ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1 )
    }

    /// public static int java.util.Arrays.binarySearch(char[],int,int,char)

    private static var binarySearch_MethodID_92: jmethodID?

    open class func binarySearch( arg0: [UInt16]?, arg1: Int, arg2: Int, arg3: UInt16 ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([CIIC)I", methodCache: &binarySearch_MethodID_92, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: [UInt16]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: UInt16 ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static int java.util.Arrays.binarySearch(byte[],byte)

    private static var binarySearch_MethodID_93: jmethodID?

    open class func binarySearch( arg0: [Int8]?, arg1: Int8 ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([BB)I", methodCache: &binarySearch_MethodID_93, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: [Int8]?, _ _arg1: Int8 ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1 )
    }

    /// public static int java.util.Arrays.binarySearch(byte[],int,int,byte)

    private static var binarySearch_MethodID_94: jmethodID?

    open class func binarySearch( arg0: [Int8]?, arg1: Int, arg2: Int, arg3: Int8 ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([BIIB)I", methodCache: &binarySearch_MethodID_94, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: [Int8]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: Int8 ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static int java.util.Arrays.binarySearch(double[],double)

    private static var binarySearch_MethodID_95: jmethodID?

    open class func binarySearch( arg0: [Double]?, arg1: Double ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([DD)I", methodCache: &binarySearch_MethodID_95, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: [Double]?, _ _arg1: Double ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1 )
    }

    /// public static int java.util.Arrays.binarySearch(double[],int,int,double)

    private static var binarySearch_MethodID_96: jmethodID?

    open class func binarySearch( arg0: [Double]?, arg1: Int, arg2: Int, arg3: Double ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([DIID)I", methodCache: &binarySearch_MethodID_96, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: [Double]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: Double ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static int java.util.Arrays.binarySearch(float[],float)

    private static var binarySearch_MethodID_97: jmethodID?

    open class func binarySearch( arg0: [Float]?, arg1: Float ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([FF)I", methodCache: &binarySearch_MethodID_97, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: [Float]?, _ _arg1: Float ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1 )
    }

    /// public static int java.util.Arrays.binarySearch(float[],int,int,float)

    private static var binarySearch_MethodID_98: jmethodID?

    open class func binarySearch( arg0: [Float]?, arg1: Int, arg2: Int, arg3: Float ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([FIIF)I", methodCache: &binarySearch_MethodID_98, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: [Float]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: Float ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public static int java.util.Arrays.binarySearch(java.lang.Object[],java.lang.Object)

    private static var binarySearch_MethodID_99: jmethodID?

    open class func binarySearch( arg0: [JavaObject]?, arg1: java_lang.JavaObject? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([Ljava/lang/Object;Ljava/lang/Object;)I", methodCache: &binarySearch_MethodID_99, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: [JavaObject]?, _ _arg1: java_lang.JavaObject? ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1 )
    }

    /// public static int java.util.Arrays.binarySearch(java.lang.Object[],java.lang.Object,java.util.Comparator)

    private static var binarySearch_MethodID_100: jmethodID?

    open class func binarySearch( arg0: [JavaObject]?, arg1: java_lang.JavaObject?, arg2: JavaComparator? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = jvalue( l: arg2?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([Ljava/lang/Object;Ljava/lang/Object;Ljava/util/Comparator;)I", methodCache: &binarySearch_MethodID_100, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: [JavaObject]?, _ _arg1: java_lang.JavaObject?, _ _arg2: JavaComparator? ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public static int java.util.Arrays.binarySearch(java.lang.Object[],int,int,java.lang.Object,java.util.Comparator)

    private static var binarySearch_MethodID_101: jmethodID?

    open class func binarySearch( arg0: [JavaObject]?, arg1: Int, arg2: Int, arg3: java_lang.JavaObject?, arg4: JavaComparator? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 5 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        __args[4] = jvalue( l: arg4?.localJavaObject( &__locals ) )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "binarySearch", methodSig: "([Ljava/lang/Object;IILjava/lang/Object;Ljava/util/Comparator;)I", methodCache: &binarySearch_MethodID_101, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func binarySearch( _ _arg0: [JavaObject]?, _ _arg1: Int, _ _arg2: Int, _ _arg3: java_lang.JavaObject?, _ _arg4: JavaComparator? ) -> Int {
        return binarySearch( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3, arg4: _arg4 )
    }

    /// private static void java.util.Arrays.swap(short[],int,int)

    /// private static void java.util.Arrays.swap(java.lang.Object[],int,int)

    /// private static void java.util.Arrays.swap(double[],int,int)

    /// private static void java.util.Arrays.swap(char[],int,int)

    /// private static void java.util.Arrays.swap(float[],int,int)

    /// private static void java.util.Arrays.swap(long[],int,int)

    /// private static void java.util.Arrays.swap(byte[],int,int)

    /// private static void java.util.Arrays.swap(int[],int,int)

    /// private static void java.util.Arrays.sort2(double[],int,int)

    /// private static void java.util.Arrays.sort2(float[],int,int)

    /// private static void java.util.Arrays.sort1(byte[],int,int)

    /// private static void java.util.Arrays.sort1(int[],int,int)

    /// private static void java.util.Arrays.sort1(char[],int,int)

    /// private static void java.util.Arrays.sort1(short[],int,int)

    /// private static void java.util.Arrays.sort1(long[],int,int)

    /// private static void java.util.Arrays.sort1(float[],int,int)

    /// private static void java.util.Arrays.sort1(double[],int,int)

    /// private static void java.util.Arrays.vecswap(char[],int,int,int)

    /// private static void java.util.Arrays.vecswap(double[],int,int,int)

    /// private static void java.util.Arrays.vecswap(short[],int,int,int)

    /// private static void java.util.Arrays.vecswap(int[],int,int,int)

    /// private static void java.util.Arrays.vecswap(long[],int,int,int)

    /// private static void java.util.Arrays.vecswap(float[],int,int,int)

    /// private static void java.util.Arrays.vecswap(byte[],int,int,int)

    /// private static int java.util.Arrays.med3(double[],int,int,int)

    /// private static int java.util.Arrays.med3(long[],int,int,int)

    /// private static int java.util.Arrays.med3(float[],int,int,int)

    /// private static int java.util.Arrays.med3(int[],int,int,int)

    /// private static int java.util.Arrays.med3(byte[],int,int,int)

    /// private static int java.util.Arrays.med3(char[],int,int,int)

    /// private static int java.util.Arrays.med3(short[],int,int,int)

    /// private static void java.util.Arrays.mergeSort(java.lang.Object[],java.lang.Object[],int,int,int)

    /// private static void java.util.Arrays.mergeSort(java.lang.Object[],java.lang.Object[],int,int,int,java.util.Comparator)

    /// private static void java.util.Arrays.rangeCheck(int,int,int)

    /// private static int java.util.Arrays.binarySearch0(short[],int,int,short)

    /// private static int java.util.Arrays.binarySearch0(java.lang.Object[],int,int,java.lang.Object)

    /// private static int java.util.Arrays.binarySearch0(float[],int,int,float)

    /// private static int java.util.Arrays.binarySearch0(double[],int,int,double)

    /// private static int java.util.Arrays.binarySearch0(byte[],int,int,byte)

    /// private static int java.util.Arrays.binarySearch0(char[],int,int,char)

    /// private static int java.util.Arrays.binarySearch0(java.lang.Object[],int,int,java.lang.Object,java.util.Comparator)

    /// private static int java.util.Arrays.binarySearch0(int[],int,int,int)

    /// private static int java.util.Arrays.binarySearch0(long[],int,int,long)

    /// public static java.util.List java.util.Arrays.asList(java.lang.Object[])

    private static var asList_MethodID_102: jmethodID?

    open class func asList( arg0: [JavaObject]? ) -> List! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "asList", methodSig: "([Ljava/lang/Object;)Ljava/util/List;", methodCache: &asList_MethodID_102, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ListForward( javaObject: __return ) : nil
    }

    open class func asList( _ _arg0: [JavaObject]? ) -> List! {
        return asList( arg0: _arg0 )
    }

    /// public static int java.util.Arrays.deepHashCode(java.lang.Object[])

    private static var deepHashCode_MethodID_103: jmethodID?

    open class func deepHashCode( arg0: [JavaObject]? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticIntMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "deepHashCode", methodSig: "([Ljava/lang/Object;)I", methodCache: &deepHashCode_MethodID_103, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open class func deepHashCode( _ _arg0: [JavaObject]? ) -> Int {
        return deepHashCode( arg0: _arg0 )
    }

    /// public static boolean java.util.Arrays.deepEquals(java.lang.Object[],java.lang.Object[])

    private static var deepEquals_MethodID_104: jmethodID?

    open class func deepEquals( arg0: [JavaObject]?, arg1: [JavaObject]? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticBooleanMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "deepEquals", methodSig: "([Ljava/lang/Object;[Ljava/lang/Object;)Z", methodCache: &deepEquals_MethodID_104, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open class func deepEquals( _ _arg0: [JavaObject]?, _ _arg1: [JavaObject]? ) -> Bool {
        return deepEquals( arg0: _arg0, arg1: _arg1 )
    }

    /// public static java.lang.String java.util.Arrays.deepToString(java.lang.Object[])

    private static var deepToString_MethodID_105: jmethodID?

    open class func deepToString( arg0: [JavaObject]? ) -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/Arrays", classCache: &ArraysJNIClass, methodName: "deepToString", methodSig: "([Ljava/lang/Object;)Ljava/lang/String;", methodCache: &deepToString_MethodID_105, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }

    open class func deepToString( _ _arg0: [JavaObject]? ) -> String! {
        return deepToString( arg0: _arg0 )
    }

    /// private static void java.util.Arrays.deepToString(java.lang.Object[],java.lang.StringBuilder,java.util.Set)

}
