
import java_swift
import java_lang

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// JAVA_HOME: /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home ///
/// Tue Dec 20 11:30:04 GMT 2016 ///

/// class java.util.logging.Logger ///

open class Logger: java_lang.JavaObject {

    public convenience init?( casting object: java_lang.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        if !object.validDownCast( toJavaClass: "java.util.logging.Logger", file, line ) {
            return nil
        }
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var LoggerJNIClass: jclass?

    /// private static final java.util.logging.Handler[] java.util.logging.Logger.emptyHandlers

    /// private static final int java.util.logging.Logger.offValue

    /// private java.util.logging.LogManager java.util.logging.Logger.manager

    /// private java.lang.String java.util.logging.Logger.name

    /// private java.util.ArrayList java.util.logging.Logger.handlers

    /// private java.lang.String java.util.logging.Logger.resourceBundleName

    /// private boolean java.util.logging.Logger.useParentHandlers

    /// private java.util.logging.Filter java.util.logging.Logger.filter

    /// private boolean java.util.logging.Logger.anonymous

    /// private java.util.ResourceBundle java.util.logging.Logger.catalog

    /// private java.lang.String java.util.logging.Logger.catalogName

    /// private java.util.Locale java.util.logging.Logger.catalogLocale

    /// private static java.lang.Object java.util.logging.Logger.treeLock

    /// private java.util.logging.Logger java.util.logging.Logger.parent

    /// private java.util.ArrayList java.util.logging.Logger.kids

    /// private java.util.logging.Level java.util.logging.Logger.levelObject

    /// private volatile int java.util.logging.Logger.levelValue

    /// public static final java.lang.String java.util.logging.Logger.GLOBAL_LOGGER_NAME

    private static var GLOBAL_LOGGER_NAME_FieldID: jfieldID?

    open static var GLOBAL_LOGGER_NAME: String! {
        get {
            let __value = JNIField.GetStaticObjectField( fieldName: "GLOBAL_LOGGER_NAME", fieldType: "Ljava/lang/String;", fieldCache: &GLOBAL_LOGGER_NAME_FieldID, className: "java/util/logging/Logger", classCache: &LoggerJNIClass )
            return JNIType.decode( type: String(), from: __value )
        }
    }

    /// public static final java.util.logging.Logger java.util.logging.Logger.global

    private static var global_FieldID: jfieldID?

    open static var global: Logger! {
        get {
            let __value = JNIField.GetStaticObjectField( fieldName: "global", fieldType: "Ljava/util/logging/Logger;", fieldCache: &global_FieldID, className: "java/util/logging/Logger", classCache: &LoggerJNIClass )
            return __value != nil ? Logger( javaObject: __value ) : nil
        }
    }

    /// static final java.lang.String java.util.logging.Logger.SYSTEM_LOGGER_RB_NAME

    /// protected java.util.logging.Logger(java.lang.String,java.lang.String)

    private static var new_MethodID_1: jmethodID?

    public convenience init( arg0: String?, arg1: String? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __object = JNIMethod.NewObject( className: "java/util/logging/Logger", classCache: &Logger.LoggerJNIClass, methodSig: "(Ljava/lang/String;Ljava/lang/String;)V", methodCache: &Logger.new_MethodID_1, args: &__args, locals: &__locals )
        self.init( javaObject: __object )
        JNI.DeleteLocalRef( __object )
    }

    public convenience init( _ _arg0: String?, _ _arg1: String? ) {
        self.init( arg0: _arg0, arg1: _arg1 )
    }

    /// private java.util.logging.Logger(java.lang.String)

    /// public void java.util.logging.Logger.log(java.util.logging.Level,java.lang.String,java.lang.Throwable)

    private static var log_MethodID_2: jmethodID?

    open func log( arg0: Level?, arg1: String?, arg2: java_lang.Throwable? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "log", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/Throwable;)V", methodCache: &Logger.log_MethodID_2, args: &__args, locals: &__locals )
    }

    open func log( _ _arg0: Level?, _ _arg1: String?, _ _arg2: java_lang.Throwable? ) {
        log( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public void java.util.logging.Logger.log(java.util.logging.LogRecord)

    private static var log_MethodID_3: jmethodID?

    open func log( arg0: LogRecord? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "log", methodSig: "(Ljava/util/logging/LogRecord;)V", methodCache: &Logger.log_MethodID_3, args: &__args, locals: &__locals )
    }

    open func log( _ _arg0: LogRecord? ) {
        log( arg0: _arg0 )
    }

    /// public void java.util.logging.Logger.log(java.util.logging.Level,java.lang.String)

    private static var log_MethodID_4: jmethodID?

    open func log( arg0: Level?, arg1: String? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "log", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;)V", methodCache: &Logger.log_MethodID_4, args: &__args, locals: &__locals )
    }

    open func log( _ _arg0: Level?, _ _arg1: String? ) {
        log( arg0: _arg0, arg1: _arg1 )
    }

    /// public void java.util.logging.Logger.log(java.util.logging.Level,java.lang.String,java.lang.Object)

    private static var log_MethodID_5: jmethodID?

    open func log( arg0: Level?, arg1: String?, arg2: java_lang.JavaObject? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "log", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/Object;)V", methodCache: &Logger.log_MethodID_5, args: &__args, locals: &__locals )
    }

    open func log( _ _arg0: Level?, _ _arg1: String?, _ _arg2: java_lang.JavaObject? ) {
        log( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public void java.util.logging.Logger.log(java.util.logging.Level,java.lang.String,java.lang.Object[])

    private static var log_MethodID_6: jmethodID?

    open func log( arg0: Level?, arg1: String?, arg2: [JavaObject]? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "log", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;[Ljava/lang/Object;)V", methodCache: &Logger.log_MethodID_6, args: &__args, locals: &__locals )
    }

    open func log( _ _arg0: Level?, _ _arg1: String?, _ _arg2: [JavaObject]? ) {
        log( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public java.lang.String java.util.logging.Logger.getName()

    private static var getName_MethodID_7: jmethodID?

    open func getName() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getName", methodSig: "()Ljava/lang/String;", methodCache: &Logger.getName_MethodID_7, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }


    /// private void java.util.logging.Logger.checkPermission() throws java.lang.SecurityException

    /// public java.util.logging.Logger java.util.logging.Logger.getParent()

    private static var getParent_MethodID_8: jmethodID?

    open func getParent() -> Logger! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getParent", methodSig: "()Ljava/util/logging/Logger;", methodCache: &Logger.getParent_MethodID_8, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Logger( javaObject: __return ) : nil
    }


    /// public void java.util.logging.Logger.setParent(java.util.logging.Logger)

    private static var setParent_MethodID_9: jmethodID?

    open func setParent( arg0: Logger? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setParent", methodSig: "(Ljava/util/logging/Logger;)V", methodCache: &Logger.setParent_MethodID_9, args: &__args, locals: &__locals )
    }

    open func setParent( _ _arg0: Logger? ) {
        setParent( arg0: _arg0 )
    }

    /// public static synchronized java.util.logging.Logger java.util.logging.Logger.getLogger(java.lang.String,java.lang.String)

    private static var getLogger_MethodID_10: jmethodID?

    open class func getLogger( arg0: String?, arg1: String? ) -> Logger! {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/logging/Logger", classCache: &LoggerJNIClass, methodName: "getLogger", methodSig: "(Ljava/lang/String;Ljava/lang/String;)Ljava/util/logging/Logger;", methodCache: &getLogger_MethodID_10, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Logger( javaObject: __return ) : nil
    }

    open class func getLogger( _ _arg0: String?, _ _arg1: String? ) -> Logger! {
        return getLogger( arg0: _arg0, arg1: _arg1 )
    }

    /// public static synchronized java.util.logging.Logger java.util.logging.Logger.getLogger(java.lang.String)

    private static var getLogger_MethodID_11: jmethodID?

    open class func getLogger( arg0: String? ) -> Logger! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/logging/Logger", classCache: &LoggerJNIClass, methodName: "getLogger", methodSig: "(Ljava/lang/String;)Ljava/util/logging/Logger;", methodCache: &getLogger_MethodID_11, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Logger( javaObject: __return ) : nil
    }

    open class func getLogger( _ _arg0: String? ) -> Logger! {
        return getLogger( arg0: _arg0 )
    }

    /// public void java.util.logging.Logger.warning(java.lang.String)

    private static var warning_MethodID_12: jmethodID?

    open func warning( arg0: String? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "warning", methodSig: "(Ljava/lang/String;)V", methodCache: &Logger.warning_MethodID_12, args: &__args, locals: &__locals )
    }

    open func warning( _ _arg0: String? ) {
        warning( arg0: _arg0 )
    }

    /// public void java.util.logging.Logger.info(java.lang.String)

    private static var info_MethodID_13: jmethodID?

    open func info( arg0: String? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "info", methodSig: "(Ljava/lang/String;)V", methodCache: &Logger.info_MethodID_13, args: &__args, locals: &__locals )
    }

    open func info( _ _arg0: String? ) {
        info( arg0: _arg0 )
    }

    /// public void java.util.logging.Logger.config(java.lang.String)

    private static var config_MethodID_14: jmethodID?

    open func config( arg0: String? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "config", methodSig: "(Ljava/lang/String;)V", methodCache: &Logger.config_MethodID_14, args: &__args, locals: &__locals )
    }

    open func config( _ _arg0: String? ) {
        config( arg0: _arg0 )
    }

    /// public boolean java.util.logging.Logger.isLoggable(java.util.logging.Level)

    private static var isLoggable_MethodID_15: jmethodID?

    open func isLoggable( arg0: Level? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isLoggable", methodSig: "(Ljava/util/logging/Level;)Z", methodCache: &Logger.isLoggable_MethodID_15, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func isLoggable( _ _arg0: Level? ) -> Bool {
        return isLoggable( arg0: _arg0 )
    }

    /// public void java.util.logging.Logger.fine(java.lang.String)

    private static var fine_MethodID_16: jmethodID?

    open func fine( arg0: String? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "fine", methodSig: "(Ljava/lang/String;)V", methodCache: &Logger.fine_MethodID_16, args: &__args, locals: &__locals )
    }

    open func fine( _ _arg0: String? ) {
        fine( arg0: _arg0 )
    }

    /// public void java.util.logging.Logger.finer(java.lang.String)

    private static var finer_MethodID_17: jmethodID?

    open func finer( arg0: String? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "finer", methodSig: "(Ljava/lang/String;)V", methodCache: &Logger.finer_MethodID_17, args: &__args, locals: &__locals )
    }

    open func finer( _ _arg0: String? ) {
        finer( arg0: _arg0 )
    }

    /// public void java.util.logging.Logger.finest(java.lang.String)

    private static var finest_MethodID_18: jmethodID?

    open func finest( arg0: String? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "finest", methodSig: "(Ljava/lang/String;)V", methodCache: &Logger.finest_MethodID_18, args: &__args, locals: &__locals )
    }

    open func finest( _ _arg0: String? ) {
        finest( arg0: _arg0 )
    }

    /// public void java.util.logging.Logger.setLevel(java.util.logging.Level) throws java.lang.SecurityException

    private static var setLevel_MethodID_19: jmethodID?

    open func setLevel( arg0: Level? ) throws /* java.lang.SecurityException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setLevel", methodSig: "(Ljava/util/logging/Level;)V", methodCache: &Logger.setLevel_MethodID_19, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.JavaSecurityException( javaObject: throwable )
        }
    }

    open func setLevel( _ _arg0: Level? ) throws /* java.lang.SecurityException */ {
        try setLevel( arg0: _arg0 )
    }

    /// public void java.util.logging.Logger.setFilter(java.util.logging.Filter) throws java.lang.SecurityException

    private static var setFilter_MethodID_20: jmethodID?

    open func setFilter( arg0: Filter? ) throws /* java.lang.SecurityException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setFilter", methodSig: "(Ljava/util/logging/Filter;)V", methodCache: &Logger.setFilter_MethodID_20, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.JavaSecurityException( javaObject: throwable )
        }
    }

    open func setFilter( _ _arg0: Filter? ) throws /* java.lang.SecurityException */ {
        try setFilter( arg0: _arg0 )
    }

    /// public java.util.logging.Filter java.util.logging.Logger.getFilter()

    private static var getFilter_MethodID_21: jmethodID?

    open func getFilter() -> Filter! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getFilter", methodSig: "()Ljava/util/logging/Filter;", methodCache: &Logger.getFilter_MethodID_21, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? FilterForward( javaObject: __return ) : nil
    }


    /// public java.util.logging.Level java.util.logging.Logger.getLevel()

    private static var getLevel_MethodID_22: jmethodID?

    open func getLevel() -> Level! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getLevel", methodSig: "()Ljava/util/logging/Level;", methodCache: &Logger.getLevel_MethodID_22, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Level( javaObject: __return ) : nil
    }


    /// public java.lang.String java.util.logging.Logger.getResourceBundleName()

    private static var getResourceBundleName_MethodID_23: jmethodID?

    open func getResourceBundleName() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getResourceBundleName", methodSig: "()Ljava/lang/String;", methodCache: &Logger.getResourceBundleName_MethodID_23, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }


    /// private static java.util.logging.Logger java.util.logging.Logger.demandLogger(java.lang.String,java.lang.String)

    /// private void java.util.logging.Logger.doSetParent(java.util.logging.Logger)

    /// public synchronized java.util.logging.Handler[] java.util.logging.Logger.getHandlers()

    private static var getHandlers_MethodID_24: jmethodID?

    open func getHandlers() -> [Handler]! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getHandlers", methodSig: "()[Ljava/util/logging/Handler;", methodCache: &Logger.getHandlers_MethodID_24, args: &__args, locals: &__locals )
        return JNIType.decode( type: [Handler](), from: __return )
    }


    /// public synchronized void java.util.logging.Logger.removeHandler(java.util.logging.Handler) throws java.lang.SecurityException

    private static var removeHandler_MethodID_25: jmethodID?

    open func removeHandler( arg0: Handler? ) throws /* java.lang.SecurityException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "removeHandler", methodSig: "(Ljava/util/logging/Handler;)V", methodCache: &Logger.removeHandler_MethodID_25, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.JavaSecurityException( javaObject: throwable )
        }
    }

    open func removeHandler( _ _arg0: Handler? ) throws /* java.lang.SecurityException */ {
        try removeHandler( arg0: _arg0 )
    }

    /// public java.util.ResourceBundle java.util.logging.Logger.getResourceBundle()

    private static var getResourceBundle_MethodID_26: jmethodID?

    open func getResourceBundle() -> ResourceBundle! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getResourceBundle", methodSig: "()Ljava/util/ResourceBundle;", methodCache: &Logger.getResourceBundle_MethodID_26, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ResourceBundle( javaObject: __return ) : nil
    }


    /// public synchronized void java.util.logging.Logger.addHandler(java.util.logging.Handler) throws java.lang.SecurityException

    private static var addHandler_MethodID_27: jmethodID?

    open func addHandler( arg0: Handler? ) throws /* java.lang.SecurityException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "addHandler", methodSig: "(Ljava/util/logging/Handler;)V", methodCache: &Logger.addHandler_MethodID_27, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.JavaSecurityException( javaObject: throwable )
        }
    }

    open func addHandler( _ _arg0: Handler? ) throws /* java.lang.SecurityException */ {
        try addHandler( arg0: _arg0 )
    }

    /// public synchronized void java.util.logging.Logger.setUseParentHandlers(boolean)

    private static var setUseParentHandlers_MethodID_28: jmethodID?

    open func setUseParentHandlers( arg0: Bool ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setUseParentHandlers", methodSig: "(Z)V", methodCache: &Logger.setUseParentHandlers_MethodID_28, args: &__args, locals: &__locals )
    }

    open func setUseParentHandlers( _ _arg0: Bool ) {
        setUseParentHandlers( arg0: _arg0 )
    }

    /// final void java.util.logging.Logger.removeChildLogger(java.util.logging.LogManager$LoggerWeakRef)

    /// private static java.util.ResourceBundle java.util.logging.Logger.findSystemResourceBundle(java.util.Locale)

    /// void java.util.logging.Logger.setLogManager(java.util.logging.LogManager)

    /// public static java.util.logging.Logger java.util.logging.Logger.getAnonymousLogger()

    private static var getAnonymousLogger_MethodID_29: jmethodID?

    open class func getAnonymousLogger() -> Logger! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/logging/Logger", classCache: &LoggerJNIClass, methodName: "getAnonymousLogger", methodSig: "()Ljava/util/logging/Logger;", methodCache: &getAnonymousLogger_MethodID_29, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Logger( javaObject: __return ) : nil
    }


    /// public static synchronized java.util.logging.Logger java.util.logging.Logger.getAnonymousLogger(java.lang.String)

    private static var getAnonymousLogger_MethodID_30: jmethodID?

    open class func getAnonymousLogger( arg0: String? ) -> Logger! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallStaticObjectMethod( className: "java/util/logging/Logger", classCache: &LoggerJNIClass, methodName: "getAnonymousLogger", methodSig: "(Ljava/lang/String;)Ljava/util/logging/Logger;", methodCache: &getAnonymousLogger_MethodID_30, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Logger( javaObject: __return ) : nil
    }

    open class func getAnonymousLogger( _ _arg0: String? ) -> Logger! {
        return getAnonymousLogger( arg0: _arg0 )
    }

    /// private void java.util.logging.Logger.doLog(java.util.logging.LogRecord)

    /// private void java.util.logging.Logger.doLog(java.util.logging.LogRecord,java.lang.String)

    /// public void java.util.logging.Logger.logp(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String,java.lang.Object[])

    private static var logp_MethodID_31: jmethodID?

    open func logp( arg0: Level?, arg1: String?, arg2: String?, arg3: String?, arg4: [JavaObject]? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 5 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        __args[4] = JNIType.encode( value: arg4, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logp", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/Object;)V", methodCache: &Logger.logp_MethodID_31, args: &__args, locals: &__locals )
    }

    open func logp( _ _arg0: Level?, _ _arg1: String?, _ _arg2: String?, _ _arg3: String?, _ _arg4: [JavaObject]? ) {
        logp( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3, arg4: _arg4 )
    }

    /// public void java.util.logging.Logger.logp(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String)

    private static var logp_MethodID_32: jmethodID?

    open func logp( arg0: Level?, arg1: String?, arg2: String?, arg3: String? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 4 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logp", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V", methodCache: &Logger.logp_MethodID_32, args: &__args, locals: &__locals )
    }

    open func logp( _ _arg0: Level?, _ _arg1: String?, _ _arg2: String?, _ _arg3: String? ) {
        logp( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3 )
    }

    /// public void java.util.logging.Logger.logp(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String,java.lang.Object)

    private static var logp_MethodID_33: jmethodID?

    open func logp( arg0: Level?, arg1: String?, arg2: String?, arg3: String?, arg4: java_lang.JavaObject? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 5 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        __args[4] = JNIType.encode( value: arg4, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logp", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/Object;)V", methodCache: &Logger.logp_MethodID_33, args: &__args, locals: &__locals )
    }

    open func logp( _ _arg0: Level?, _ _arg1: String?, _ _arg2: String?, _ _arg3: String?, _ _arg4: java_lang.JavaObject? ) {
        logp( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3, arg4: _arg4 )
    }

    /// public void java.util.logging.Logger.logp(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String,java.lang.Throwable)

    private static var logp_MethodID_34: jmethodID?

    open func logp( arg0: Level?, arg1: String?, arg2: String?, arg3: String?, arg4: java_lang.Throwable? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 5 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        __args[4] = JNIType.encode( value: arg4, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logp", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/Throwable;)V", methodCache: &Logger.logp_MethodID_34, args: &__args, locals: &__locals )
    }

    open func logp( _ _arg0: Level?, _ _arg1: String?, _ _arg2: String?, _ _arg3: String?, _ _arg4: java_lang.Throwable? ) {
        logp( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3, arg4: _arg4 )
    }

    /// public void java.util.logging.Logger.logrb(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String,java.lang.String)

    private static var logrb_MethodID_35: jmethodID?

    open func logrb( arg0: Level?, arg1: String?, arg2: String?, arg3: String?, arg4: String? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 5 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        __args[4] = JNIType.encode( value: arg4, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logrb", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V", methodCache: &Logger.logrb_MethodID_35, args: &__args, locals: &__locals )
    }

    open func logrb( _ _arg0: Level?, _ _arg1: String?, _ _arg2: String?, _ _arg3: String?, _ _arg4: String? ) {
        logrb( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3, arg4: _arg4 )
    }

    /// public void java.util.logging.Logger.logrb(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.Throwable)

    private static var logrb_MethodID_36: jmethodID?

    open func logrb( arg0: Level?, arg1: String?, arg2: String?, arg3: String?, arg4: String?, arg5: java_lang.Throwable? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 6 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        __args[4] = JNIType.encode( value: arg4, locals: &__locals )
        __args[5] = JNIType.encode( value: arg5, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logrb", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/Throwable;)V", methodCache: &Logger.logrb_MethodID_36, args: &__args, locals: &__locals )
    }

    open func logrb( _ _arg0: Level?, _ _arg1: String?, _ _arg2: String?, _ _arg3: String?, _ _arg4: String?, _ _arg5: java_lang.Throwable? ) {
        logrb( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3, arg4: _arg4, arg5: _arg5 )
    }

    /// public void java.util.logging.Logger.logrb(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.Object[])

    private static var logrb_MethodID_37: jmethodID?

    open func logrb( arg0: Level?, arg1: String?, arg2: String?, arg3: String?, arg4: String?, arg5: [JavaObject]? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 6 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        __args[4] = JNIType.encode( value: arg4, locals: &__locals )
        __args[5] = JNIType.encode( value: arg5, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logrb", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/Object;)V", methodCache: &Logger.logrb_MethodID_37, args: &__args, locals: &__locals )
    }

    open func logrb( _ _arg0: Level?, _ _arg1: String?, _ _arg2: String?, _ _arg3: String?, _ _arg4: String?, _ _arg5: [JavaObject]? ) {
        logrb( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3, arg4: _arg4, arg5: _arg5 )
    }

    /// public void java.util.logging.Logger.logrb(java.util.logging.Level,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.Object)

    private static var logrb_MethodID_38: jmethodID?

    open func logrb( arg0: Level?, arg1: String?, arg2: String?, arg3: String?, arg4: String?, arg5: java_lang.JavaObject? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 6 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        __args[3] = JNIType.encode( value: arg3, locals: &__locals )
        __args[4] = JNIType.encode( value: arg4, locals: &__locals )
        __args[5] = JNIType.encode( value: arg5, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "logrb", methodSig: "(Ljava/util/logging/Level;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/Object;)V", methodCache: &Logger.logrb_MethodID_38, args: &__args, locals: &__locals )
    }

    open func logrb( _ _arg0: Level?, _ _arg1: String?, _ _arg2: String?, _ _arg3: String?, _ _arg4: String?, _ _arg5: java_lang.JavaObject? ) {
        logrb( arg0: _arg0, arg1: _arg1, arg2: _arg2, arg3: _arg3, arg4: _arg4, arg5: _arg5 )
    }

    /// public void java.util.logging.Logger.entering(java.lang.String,java.lang.String)

    private static var entering_MethodID_39: jmethodID?

    open func entering( arg0: String?, arg1: String? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "entering", methodSig: "(Ljava/lang/String;Ljava/lang/String;)V", methodCache: &Logger.entering_MethodID_39, args: &__args, locals: &__locals )
    }

    open func entering( _ _arg0: String?, _ _arg1: String? ) {
        entering( arg0: _arg0, arg1: _arg1 )
    }

    /// public void java.util.logging.Logger.entering(java.lang.String,java.lang.String,java.lang.Object[])

    private static var entering_MethodID_40: jmethodID?

    open func entering( arg0: String?, arg1: String?, arg2: [JavaObject]? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "entering", methodSig: "(Ljava/lang/String;Ljava/lang/String;[Ljava/lang/Object;)V", methodCache: &Logger.entering_MethodID_40, args: &__args, locals: &__locals )
    }

    open func entering( _ _arg0: String?, _ _arg1: String?, _ _arg2: [JavaObject]? ) {
        entering( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public void java.util.logging.Logger.entering(java.lang.String,java.lang.String,java.lang.Object)

    private static var entering_MethodID_41: jmethodID?

    open func entering( arg0: String?, arg1: String?, arg2: java_lang.JavaObject? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "entering", methodSig: "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Object;)V", methodCache: &Logger.entering_MethodID_41, args: &__args, locals: &__locals )
    }

    open func entering( _ _arg0: String?, _ _arg1: String?, _ _arg2: java_lang.JavaObject? ) {
        entering( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public void java.util.logging.Logger.exiting(java.lang.String,java.lang.String)

    private static var exiting_MethodID_42: jmethodID?

    open func exiting( arg0: String?, arg1: String? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "exiting", methodSig: "(Ljava/lang/String;Ljava/lang/String;)V", methodCache: &Logger.exiting_MethodID_42, args: &__args, locals: &__locals )
    }

    open func exiting( _ _arg0: String?, _ _arg1: String? ) {
        exiting( arg0: _arg0, arg1: _arg1 )
    }

    /// public void java.util.logging.Logger.exiting(java.lang.String,java.lang.String,java.lang.Object)

    private static var exiting_MethodID_43: jmethodID?

    open func exiting( arg0: String?, arg1: String?, arg2: java_lang.JavaObject? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "exiting", methodSig: "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Object;)V", methodCache: &Logger.exiting_MethodID_43, args: &__args, locals: &__locals )
    }

    open func exiting( _ _arg0: String?, _ _arg1: String?, _ _arg2: java_lang.JavaObject? ) {
        exiting( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public void java.util.logging.Logger.throwing(java.lang.String,java.lang.String,java.lang.Throwable)

    private static var throwing_MethodID_44: jmethodID?

    open func throwing( arg0: String?, arg1: String?, arg2: java_lang.Throwable? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "throwing", methodSig: "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Throwable;)V", methodCache: &Logger.throwing_MethodID_44, args: &__args, locals: &__locals )
    }

    open func throwing( _ _arg0: String?, _ _arg1: String?, _ _arg2: java_lang.Throwable? ) {
        throwing( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public void java.util.logging.Logger.severe(java.lang.String)

    private static var severe_MethodID_45: jmethodID?

    open func severe( arg0: String? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "severe", methodSig: "(Ljava/lang/String;)V", methodCache: &Logger.severe_MethodID_45, args: &__args, locals: &__locals )
    }

    open func severe( _ _arg0: String? ) {
        severe( arg0: _arg0 )
    }

    /// public synchronized boolean java.util.logging.Logger.getUseParentHandlers()

    private static var getUseParentHandlers_MethodID_46: jmethodID?

    open func getUseParentHandlers() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "getUseParentHandlers", methodSig: "()Z", methodCache: &Logger.getUseParentHandlers_MethodID_46, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// private synchronized java.util.ResourceBundle java.util.logging.Logger.findResourceBundle(java.lang.String)

    /// private synchronized void java.util.logging.Logger.setupResourceInfo(java.lang.String)

    /// private void java.util.logging.Logger.updateEffectiveLevel()

    /// private java.lang.String java.util.logging.Logger.getEffectiveResourceBundleName()

}
