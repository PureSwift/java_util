
import java_swift
import java_lang

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// JAVA_HOME: /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home ///
/// Tue Dec 20 11:30:06 GMT 2016 ///

/// class java.util.concurrent.locks.AbstractQueuedSynchronizer ///

open class AbstractQueuedSynchronizer: AbstractOwnableSynchronizer {

    public convenience init?( casting object: java_lang.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        if !object.validDownCast( toJavaClass: "java.util.concurrent.locks.AbstractQueuedSynchronizer", file, line ) {
            return nil
        }
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var AbstractQueuedSynchronizerJNIClass: jclass?

    /// private static final long java.util.concurrent.locks.AbstractQueuedSynchronizer.serialVersionUID

    /// private transient volatile java.util.concurrent.locks.AbstractQueuedSynchronizer$Node java.util.concurrent.locks.AbstractQueuedSynchronizer.head

    /// private transient volatile java.util.concurrent.locks.AbstractQueuedSynchronizer$Node java.util.concurrent.locks.AbstractQueuedSynchronizer.tail

    /// private volatile int java.util.concurrent.locks.AbstractQueuedSynchronizer.state

    /// static final long java.util.concurrent.locks.AbstractQueuedSynchronizer.spinForTimeoutThreshold

    /// private static final sun.misc.Unsafe java.util.concurrent.locks.AbstractQueuedSynchronizer.unsafe

    /// private static final long java.util.concurrent.locks.AbstractQueuedSynchronizer.stateOffset

    /// private static final long java.util.concurrent.locks.AbstractQueuedSynchronizer.headOffset

    /// private static final long java.util.concurrent.locks.AbstractQueuedSynchronizer.tailOffset

    /// private static final long java.util.concurrent.locks.AbstractQueuedSynchronizer.waitStatusOffset

    /// private static final long java.util.concurrent.locks.AbstractQueuedSynchronizer.nextOffset

    /// private static final long java.util.concurrent.locks.AbstractOwnableSynchronizer.serialVersionUID

    /// private transient java.lang.Thread java.util.concurrent.locks.AbstractOwnableSynchronizer.exclusiveOwnerThread

    /// protected java.util.concurrent.locks.AbstractQueuedSynchronizer()

    private static var new_MethodID_1: jmethodID?

    public convenience init() {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __object = JNIMethod.NewObject( className: "java/util/concurrent/locks/AbstractQueuedSynchronizer", classCache: &AbstractQueuedSynchronizer.AbstractQueuedSynchronizerJNIClass, methodSig: "()V", methodCache: &AbstractQueuedSynchronizer.new_MethodID_1, args: &__args, locals: &__locals )
        self.init( javaObject: __object )
        JNI.DeleteLocalRef( __object )
    }

    /// public java.lang.String java.util.concurrent.locks.AbstractQueuedSynchronizer.toString()

    /// static void java.util.concurrent.locks.AbstractQueuedSynchronizer.access$000()

    /// protected final int java.util.concurrent.locks.AbstractQueuedSynchronizer.getState()

    private static var getState_MethodID_2: jmethodID?

    open func getState() -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getState", methodSig: "()I", methodCache: &AbstractQueuedSynchronizer.getState_MethodID_2, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }


    /// protected final void java.util.concurrent.locks.AbstractQueuedSynchronizer.setState(int)

    private static var setState_MethodID_3: jmethodID?

    open func setState( arg0: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setState", methodSig: "(I)V", methodCache: &AbstractQueuedSynchronizer.setState_MethodID_3, args: &__args, locals: &__locals )
    }

    open func setState( _ _arg0: Int ) {
        setState( arg0: _arg0 )
    }

    /// public final void java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(int)

    private static var acquire_MethodID_4: jmethodID?

    open func acquire( arg0: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "acquire", methodSig: "(I)V", methodCache: &AbstractQueuedSynchronizer.acquire_MethodID_4, args: &__args, locals: &__locals )
    }

    open func acquire( _ _arg0: Int ) {
        acquire( arg0: _arg0 )
    }

    /// public final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.release(int)

    private static var release_MethodID_5: jmethodID?

    open func release( arg0: Int ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "release", methodSig: "(I)Z", methodCache: &AbstractQueuedSynchronizer.release_MethodID_5, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func release( _ _arg0: Int ) -> Bool {
        return release( arg0: _arg0 )
    }

    /// public final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.hasQueuedThreads()

    private static var hasQueuedThreads_MethodID_6: jmethodID?

    open func hasQueuedThreads() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "hasQueuedThreads", methodSig: "()Z", methodCache: &AbstractQueuedSynchronizer.hasQueuedThreads_MethodID_6, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public final int java.util.concurrent.locks.AbstractQueuedSynchronizer.getQueueLength()

    private static var getQueueLength_MethodID_7: jmethodID?

    open func getQueueLength() -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getQueueLength", methodSig: "()I", methodCache: &AbstractQueuedSynchronizer.getQueueLength_MethodID_7, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }


    /// public final java.util.Collection java.util.concurrent.locks.AbstractQueuedSynchronizer.getQueuedThreads()

    private static var getQueuedThreads_MethodID_8: jmethodID?

    open func getQueuedThreads() -> Collection! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getQueuedThreads", methodSig: "()Ljava/util/Collection;", methodCache: &AbstractQueuedSynchronizer.getQueuedThreads_MethodID_8, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectionForward( javaObject: __return ) : nil
    }


    /// public final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.hasWaiters(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)

    private static var hasWaiters_MethodID_9: jmethodID?

    open func hasWaiters( arg0: /* java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject */ UnclassedObject? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "hasWaiters", methodSig: "(Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject;)Z", methodCache: &AbstractQueuedSynchronizer.hasWaiters_MethodID_9, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func hasWaiters( _ _arg0: /* java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject */ UnclassedObject? ) -> Bool {
        return hasWaiters( arg0: _arg0 )
    }

    /// public final int java.util.concurrent.locks.AbstractQueuedSynchronizer.getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)

    private static var getWaitQueueLength_MethodID_10: jmethodID?

    open func getWaitQueueLength( arg0: /* java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject */ UnclassedObject? ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "getWaitQueueLength", methodSig: "(Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject;)I", methodCache: &AbstractQueuedSynchronizer.getWaitQueueLength_MethodID_10, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open func getWaitQueueLength( _ _arg0: /* java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject */ UnclassedObject? ) -> Int {
        return getWaitQueueLength( arg0: _arg0 )
    }

    /// public final java.util.Collection java.util.concurrent.locks.AbstractQueuedSynchronizer.getWaitingThreads(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)

    private static var getWaitingThreads_MethodID_11: jmethodID?

    open func getWaitingThreads( arg0: /* java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject */ UnclassedObject? ) -> Collection! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getWaitingThreads", methodSig: "(Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject;)Ljava/util/Collection;", methodCache: &AbstractQueuedSynchronizer.getWaitingThreads_MethodID_11, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectionForward( javaObject: __return ) : nil
    }

    open func getWaitingThreads( _ _arg0: /* java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject */ UnclassedObject? ) -> Collection! {
        return getWaitingThreads( arg0: _arg0 )
    }

    /// public final void java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(int) throws java.lang.InterruptedException

    private static var acquireInterruptibly_MethodID_12: jmethodID?

    open func acquireInterruptibly( arg0: Int ) throws /* java.lang.InterruptedException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "acquireInterruptibly", methodSig: "(I)V", methodCache: &AbstractQueuedSynchronizer.acquireInterruptibly_MethodID_12, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.InterruptedException( javaObject: throwable )
        }
    }

    open func acquireInterruptibly( _ _arg0: Int ) throws /* java.lang.InterruptedException */ {
        try acquireInterruptibly( arg0: _arg0 )
    }

    /// public final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquireNanos(int,long) throws java.lang.InterruptedException

    private static var tryAcquireNanos_MethodID_13: jmethodID?

    open func tryAcquireNanos( arg0: Int, arg1: Int64 ) throws /* java.lang.InterruptedException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "tryAcquireNanos", methodSig: "(IJ)Z", methodCache: &AbstractQueuedSynchronizer.tryAcquireNanos_MethodID_13, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.InterruptedException( javaObject: throwable )
        }
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func tryAcquireNanos( _ _arg0: Int, _ _arg1: Int64 ) throws /* java.lang.InterruptedException */ -> Bool {
        return try tryAcquireNanos( arg0: _arg0, arg1: _arg1 )
    }

    /// protected boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.isHeldExclusively()

    private static var isHeldExclusively_MethodID_14: jmethodID?

    open func isHeldExclusively() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isHeldExclusively", methodSig: "()Z", methodCache: &AbstractQueuedSynchronizer.isHeldExclusively_MethodID_14, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.isQueued(java.lang.Thread)

    private static var isQueued_MethodID_15: jmethodID?

    open func isQueued( arg0: java_lang.Thread? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isQueued", methodSig: "(Ljava/lang/Thread;)Z", methodCache: &AbstractQueuedSynchronizer.isQueued_MethodID_15, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func isQueued( _ _arg0: java_lang.Thread? ) -> Bool {
        return isQueued( arg0: _arg0 )
    }

    /// protected boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquire(int)

    private static var tryAcquire_MethodID_16: jmethodID?

    open func tryAcquire( arg0: Int ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "tryAcquire", methodSig: "(I)Z", methodCache: &AbstractQueuedSynchronizer.tryAcquire_MethodID_16, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func tryAcquire( _ _arg0: Int ) -> Bool {
        return tryAcquire( arg0: _arg0 )
    }

    /// protected final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState(int,int)

    private static var compareAndSetState_MethodID_17: jmethodID?

    open func compareAndSetState( arg0: Int, arg1: Int ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "compareAndSetState", methodSig: "(II)Z", methodCache: &AbstractQueuedSynchronizer.compareAndSetState_MethodID_17, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func compareAndSetState( _ _arg0: Int, _ _arg1: Int ) -> Bool {
        return compareAndSetState( arg0: _arg0, arg1: _arg1 )
    }

    /// protected boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.tryRelease(int)

    private static var tryRelease_MethodID_18: jmethodID?

    open func tryRelease( arg0: Int ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "tryRelease", methodSig: "(I)Z", methodCache: &AbstractQueuedSynchronizer.tryRelease_MethodID_18, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func tryRelease( _ _arg0: Int ) -> Bool {
        return tryRelease( arg0: _arg0 )
    }

    /// private java.util.concurrent.locks.AbstractQueuedSynchronizer$Node java.util.concurrent.locks.AbstractQueuedSynchronizer.enq(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

    /// private java.util.concurrent.locks.AbstractQueuedSynchronizer$Node java.util.concurrent.locks.AbstractQueuedSynchronizer.addWaiter(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

    /// private void java.util.concurrent.locks.AbstractQueuedSynchronizer.setHead(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

    /// private void java.util.concurrent.locks.AbstractQueuedSynchronizer.unparkSuccessor(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

    /// private void java.util.concurrent.locks.AbstractQueuedSynchronizer.doReleaseShared()

    /// private void java.util.concurrent.locks.AbstractQueuedSynchronizer.setHeadAndPropagate(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node,int)

    /// private void java.util.concurrent.locks.AbstractQueuedSynchronizer.cancelAcquire(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

    /// private static boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.shouldParkAfterFailedAcquire(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node,java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

    /// private static void java.util.concurrent.locks.AbstractQueuedSynchronizer.selfInterrupt()

    /// private final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.parkAndCheckInterrupt()

    /// final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireQueued(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node,int)

    /// private void java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(int) throws java.lang.InterruptedException

    /// private boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireNanos(int,long) throws java.lang.InterruptedException

    /// private void java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireShared(int)

    /// private void java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedInterruptibly(int) throws java.lang.InterruptedException

    /// private boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireSharedNanos(int,long) throws java.lang.InterruptedException

    /// protected int java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquireShared(int)

    private static var tryAcquireShared_MethodID_19: jmethodID?

    open func tryAcquireShared( arg0: Int ) -> Int {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallIntMethod( object: javaObject, methodName: "tryAcquireShared", methodSig: "(I)I", methodCache: &AbstractQueuedSynchronizer.tryAcquireShared_MethodID_19, args: &__args, locals: &__locals )
        return JNIType.decode( type: Int(), from: __return )
    }

    open func tryAcquireShared( _ _arg0: Int ) -> Int {
        return tryAcquireShared( arg0: _arg0 )
    }

    /// protected boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.tryReleaseShared(int)

    private static var tryReleaseShared_MethodID_20: jmethodID?

    open func tryReleaseShared( arg0: Int ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "tryReleaseShared", methodSig: "(I)Z", methodCache: &AbstractQueuedSynchronizer.tryReleaseShared_MethodID_20, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func tryReleaseShared( _ _arg0: Int ) -> Bool {
        return tryReleaseShared( arg0: _arg0 )
    }

    /// public final void java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireShared(int)

    private static var acquireShared_MethodID_21: jmethodID?

    open func acquireShared( arg0: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "acquireShared", methodSig: "(I)V", methodCache: &AbstractQueuedSynchronizer.acquireShared_MethodID_21, args: &__args, locals: &__locals )
    }

    open func acquireShared( _ _arg0: Int ) {
        acquireShared( arg0: _arg0 )
    }

    /// public final void java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireSharedInterruptibly(int) throws java.lang.InterruptedException

    private static var acquireSharedInterruptibly_MethodID_22: jmethodID?

    open func acquireSharedInterruptibly( arg0: Int ) throws /* java.lang.InterruptedException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "acquireSharedInterruptibly", methodSig: "(I)V", methodCache: &AbstractQueuedSynchronizer.acquireSharedInterruptibly_MethodID_22, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.InterruptedException( javaObject: throwable )
        }
    }

    open func acquireSharedInterruptibly( _ _arg0: Int ) throws /* java.lang.InterruptedException */ {
        try acquireSharedInterruptibly( arg0: _arg0 )
    }

    /// public final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.tryAcquireSharedNanos(int,long) throws java.lang.InterruptedException

    private static var tryAcquireSharedNanos_MethodID_23: jmethodID?

    open func tryAcquireSharedNanos( arg0: Int, arg1: Int64 ) throws /* java.lang.InterruptedException */ -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 2 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "tryAcquireSharedNanos", methodSig: "(IJ)Z", methodCache: &AbstractQueuedSynchronizer.tryAcquireSharedNanos_MethodID_23, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.InterruptedException( javaObject: throwable )
        }
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func tryAcquireSharedNanos( _ _arg0: Int, _ _arg1: Int64 ) throws /* java.lang.InterruptedException */ -> Bool {
        return try tryAcquireSharedNanos( arg0: _arg0, arg1: _arg1 )
    }

    /// public final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.releaseShared(int)

    private static var releaseShared_MethodID_24: jmethodID?

    open func releaseShared( arg0: Int ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "releaseShared", methodSig: "(I)Z", methodCache: &AbstractQueuedSynchronizer.releaseShared_MethodID_24, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func releaseShared( _ _arg0: Int ) -> Bool {
        return releaseShared( arg0: _arg0 )
    }

    /// public final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.hasContended()

    private static var hasContended_MethodID_25: jmethodID?

    open func hasContended() -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "hasContended", methodSig: "()Z", methodCache: &AbstractQueuedSynchronizer.hasContended_MethodID_25, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }


    /// public final java.lang.Thread java.util.concurrent.locks.AbstractQueuedSynchronizer.getFirstQueuedThread()

    private static var getFirstQueuedThread_MethodID_26: jmethodID?

    open func getFirstQueuedThread() -> java_lang.Thread! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getFirstQueuedThread", methodSig: "()Ljava/lang/Thread;", methodCache: &AbstractQueuedSynchronizer.getFirstQueuedThread_MethodID_26, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? java_lang.Thread( javaObject: __return ) : nil
    }


    /// private java.lang.Thread java.util.concurrent.locks.AbstractQueuedSynchronizer.fullGetFirstQueuedThread()

    /// final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.apparentlyFirstQueuedIsExclusive()

    /// final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.isFirst(java.lang.Thread)

    /// final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.fullIsFirst(java.lang.Thread)

    /// public final java.util.Collection java.util.concurrent.locks.AbstractQueuedSynchronizer.getExclusiveQueuedThreads()

    private static var getExclusiveQueuedThreads_MethodID_27: jmethodID?

    open func getExclusiveQueuedThreads() -> Collection! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getExclusiveQueuedThreads", methodSig: "()Ljava/util/Collection;", methodCache: &AbstractQueuedSynchronizer.getExclusiveQueuedThreads_MethodID_27, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectionForward( javaObject: __return ) : nil
    }


    /// public final java.util.Collection java.util.concurrent.locks.AbstractQueuedSynchronizer.getSharedQueuedThreads()

    private static var getSharedQueuedThreads_MethodID_28: jmethodID?

    open func getSharedQueuedThreads() -> Collection! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getSharedQueuedThreads", methodSig: "()Ljava/util/Collection;", methodCache: &AbstractQueuedSynchronizer.getSharedQueuedThreads_MethodID_28, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? CollectionForward( javaObject: __return ) : nil
    }


    /// final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.isOnSyncQueue(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

    /// private boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.findNodeFromTail(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

    /// final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.transferForSignal(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

    /// final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.transferAfterCancelledWait(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

    /// final int java.util.concurrent.locks.AbstractQueuedSynchronizer.fullyRelease(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

    /// public final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.owns(java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)

    private static var owns_MethodID_29: jmethodID?

    open func owns( arg0: /* java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject */ UnclassedObject? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "owns", methodSig: "(Ljava/util/concurrent/locks/AbstractQueuedSynchronizer$ConditionObject;)Z", methodCache: &AbstractQueuedSynchronizer.owns_MethodID_29, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func owns( _ _arg0: /* java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject */ UnclassedObject? ) -> Bool {
        return owns( arg0: _arg0 )
    }

    /// private final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetHead(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

    /// private final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetTail(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node,java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

    /// private static final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetWaitStatus(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node,int,int)

    /// private static final boolean java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetNext(java.util.concurrent.locks.AbstractQueuedSynchronizer$Node,java.util.concurrent.locks.AbstractQueuedSynchronizer$Node,java.util.concurrent.locks.AbstractQueuedSynchronizer$Node)

}
