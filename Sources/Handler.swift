
import java_swift
import java_lang

/// generated by: genswift.java 'java/lang|java/util|java/sql|java/awt|javax/swing' ///

/// JAVA_HOME: /Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home ///
/// Tue Dec 20 11:30:04 GMT 2016 ///

/// class java.util.logging.Handler ///

open class Handler: java_lang.JavaObject {

    public convenience init?( casting object: java_lang.JavaObject, _ file: StaticString = #file, _ line: Int = #line ) {
        self.init( javaObject: nil )
        if !object.validDownCast( toJavaClass: "java.util.logging.Handler", file, line ) {
            return nil
        }
        object.withJavaObject {
            self.javaObject = $0
        }
    }

    private static var HandlerJNIClass: jclass?

    /// private static final int java.util.logging.Handler.offValue

    /// private java.util.logging.LogManager java.util.logging.Handler.manager

    /// private java.util.logging.Filter java.util.logging.Handler.filter

    /// private java.util.logging.Formatter java.util.logging.Handler.formatter

    /// private java.util.logging.Level java.util.logging.Handler.logLevel

    /// private java.util.logging.ErrorManager java.util.logging.Handler.errorManager

    /// private java.lang.String java.util.logging.Handler.encoding

    /// boolean java.util.logging.Handler.sealed

    /// protected java.util.logging.Handler()

    private static var new_MethodID_1: jmethodID?

    public convenience init() {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __object = JNIMethod.NewObject( className: "java/util/logging/Handler", classCache: &Handler.HandlerJNIClass, methodSig: "()V", methodCache: &Handler.new_MethodID_1, args: &__args, locals: &__locals )
        self.init( javaObject: __object )
        JNI.DeleteLocalRef( __object )
    }

    /// void java.util.logging.Handler.checkPermission() throws java.lang.SecurityException

    /// public abstract void java.util.logging.Handler.flush()

    private static var flush_MethodID_2: jmethodID?

    open func flush() {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "flush", methodSig: "()V", methodCache: &Handler.flush_MethodID_2, args: &__args, locals: &__locals )
    }


    /// public abstract void java.util.logging.Handler.close() throws java.lang.SecurityException

    private static var close_MethodID_3: jmethodID?

    open func close() throws /* java.lang.SecurityException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "close", methodSig: "()V", methodCache: &Handler.close_MethodID_3, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.JavaSecurityException( javaObject: throwable )
        }
    }


    /// public java.lang.String java.util.logging.Handler.getEncoding()

    private static var getEncoding_MethodID_4: jmethodID?

    open func getEncoding() -> String! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getEncoding", methodSig: "()Ljava/lang/String;", methodCache: &Handler.getEncoding_MethodID_4, args: &__args, locals: &__locals )
        return JNIType.decode( type: String(), from: __return )
    }


    /// public boolean java.util.logging.Handler.isLoggable(java.util.logging.LogRecord)

    private static var isLoggable_MethodID_5: jmethodID?

    open func isLoggable( arg0: LogRecord? ) -> Bool {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        let __return = JNIMethod.CallBooleanMethod( object: javaObject, methodName: "isLoggable", methodSig: "(Ljava/util/logging/LogRecord;)Z", methodCache: &Handler.isLoggable_MethodID_5, args: &__args, locals: &__locals )
        return JNIType.decode( type: Bool(), from: __return )
    }

    open func isLoggable( _ _arg0: LogRecord? ) -> Bool {
        return isLoggable( arg0: _arg0 )
    }

    /// public synchronized void java.util.logging.Handler.setLevel(java.util.logging.Level) throws java.lang.SecurityException

    private static var setLevel_MethodID_6: jmethodID?

    open func setLevel( arg0: Level? ) throws /* java.lang.SecurityException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setLevel", methodSig: "(Ljava/util/logging/Level;)V", methodCache: &Handler.setLevel_MethodID_6, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.JavaSecurityException( javaObject: throwable )
        }
    }

    open func setLevel( _ _arg0: Level? ) throws /* java.lang.SecurityException */ {
        try setLevel( arg0: _arg0 )
    }

    /// public abstract void java.util.logging.Handler.publish(java.util.logging.LogRecord)

    private static var publish_MethodID_7: jmethodID?

    open func publish( arg0: LogRecord? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "publish", methodSig: "(Ljava/util/logging/LogRecord;)V", methodCache: &Handler.publish_MethodID_7, args: &__args, locals: &__locals )
    }

    open func publish( _ _arg0: LogRecord? ) {
        publish( arg0: _arg0 )
    }

    /// public void java.util.logging.Handler.setFilter(java.util.logging.Filter) throws java.lang.SecurityException

    private static var setFilter_MethodID_8: jmethodID?

    open func setFilter( arg0: Filter? ) throws /* java.lang.SecurityException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = jvalue( l: arg0?.localJavaObject( &__locals ) )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setFilter", methodSig: "(Ljava/util/logging/Filter;)V", methodCache: &Handler.setFilter_MethodID_8, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.JavaSecurityException( javaObject: throwable )
        }
    }

    open func setFilter( _ _arg0: Filter? ) throws /* java.lang.SecurityException */ {
        try setFilter( arg0: _arg0 )
    }

    /// public void java.util.logging.Handler.setFormatter(java.util.logging.Formatter) throws java.lang.SecurityException

    private static var setFormatter_MethodID_9: jmethodID?

    open func setFormatter( arg0: logging_Formatter? ) throws /* java.lang.SecurityException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setFormatter", methodSig: "(Ljava/util/logging/Formatter;)V", methodCache: &Handler.setFormatter_MethodID_9, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.JavaSecurityException( javaObject: throwable )
        }
    }

    open func setFormatter( _ _arg0: logging_Formatter? ) throws /* java.lang.SecurityException */ {
        try setFormatter( arg0: _arg0 )
    }

    /// public void java.util.logging.Handler.setEncoding(java.lang.String) throws java.lang.SecurityException,java.io.UnsupportedEncodingException

    private static var setEncoding_MethodID_10: jmethodID?

    open func setEncoding( arg0: String? ) throws /* java.lang.SecurityException, java.io.UnsupportedEncodingException */ {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setEncoding", methodSig: "(Ljava/lang/String;)V", methodCache: &Handler.setEncoding_MethodID_10, args: &__args, locals: &__locals )
        if let throwable = JNI.ExceptionCheck() {
            throw java_lang.JavaSecurityException( javaObject: throwable )
        }
    }

    open func setEncoding( _ _arg0: String? ) throws /* java.lang.SecurityException, java.io.UnsupportedEncodingException */ {
        try setEncoding( arg0: _arg0 )
    }

    /// public java.util.logging.Formatter java.util.logging.Handler.getFormatter()

    private static var getFormatter_MethodID_11: jmethodID?

    open func getFormatter() -> logging_Formatter! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getFormatter", methodSig: "()Ljava/util/logging/Formatter;", methodCache: &Handler.getFormatter_MethodID_11, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? logging_Formatter( javaObject: __return ) : nil
    }


    /// protected void java.util.logging.Handler.reportError(java.lang.String,java.lang.Exception,int)

    private static var reportError_MethodID_12: jmethodID?

    open func reportError( arg0: String?, arg1: java_lang.Exception?, arg2: Int ) {
        var __args = [jvalue]( repeating: jvalue(), count: 3 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        __args[1] = JNIType.encode( value: arg1, locals: &__locals )
        __args[2] = JNIType.encode( value: arg2, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "reportError", methodSig: "(Ljava/lang/String;Ljava/lang/Exception;I)V", methodCache: &Handler.reportError_MethodID_12, args: &__args, locals: &__locals )
    }

    open func reportError( _ _arg0: String?, _ _arg1: java_lang.Exception?, _ _arg2: Int ) {
        reportError( arg0: _arg0, arg1: _arg1, arg2: _arg2 )
    }

    /// public java.util.logging.Filter java.util.logging.Handler.getFilter()

    private static var getFilter_MethodID_13: jmethodID?

    open func getFilter() -> Filter! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getFilter", methodSig: "()Ljava/util/logging/Filter;", methodCache: &Handler.getFilter_MethodID_13, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? FilterForward( javaObject: __return ) : nil
    }


    /// public void java.util.logging.Handler.setErrorManager(java.util.logging.ErrorManager)

    private static var setErrorManager_MethodID_14: jmethodID?

    open func setErrorManager( arg0: ErrorManager? ) {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        __args[0] = JNIType.encode( value: arg0, locals: &__locals )
        JNIMethod.CallVoidMethod( object: javaObject, methodName: "setErrorManager", methodSig: "(Ljava/util/logging/ErrorManager;)V", methodCache: &Handler.setErrorManager_MethodID_14, args: &__args, locals: &__locals )
    }

    open func setErrorManager( _ _arg0: ErrorManager? ) {
        setErrorManager( arg0: _arg0 )
    }

    /// public java.util.logging.ErrorManager java.util.logging.Handler.getErrorManager()

    private static var getErrorManager_MethodID_15: jmethodID?

    open func getErrorManager() -> ErrorManager! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getErrorManager", methodSig: "()Ljava/util/logging/ErrorManager;", methodCache: &Handler.getErrorManager_MethodID_15, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? ErrorManager( javaObject: __return ) : nil
    }


    /// public synchronized java.util.logging.Level java.util.logging.Handler.getLevel()

    private static var getLevel_MethodID_16: jmethodID?

    open func getLevel() -> Level! {
        var __args = [jvalue]( repeating: jvalue(), count: 1 )
        var __locals = [jobject]()
        let __return = JNIMethod.CallObjectMethod( object: javaObject, methodName: "getLevel", methodSig: "()Ljava/util/logging/Level;", methodCache: &Handler.getLevel_MethodID_16, args: &__args, locals: &__locals )
        defer { JNI.DeleteLocalRef( __return ) }
        return __return != nil ? Level( javaObject: __return ) : nil
    }


}
